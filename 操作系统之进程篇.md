# 操作系统之进程篇

# 进程定义和概念

​	对于进程的定义，从不同的角度出发会有不同的定义，其中比较典型的是：**进程是系统进行资源分配和调度的一个独立单位。**

​	进程的概念与程序是离不开的。在单道程序环境中，程序在处理器中是顺序执行的，只有当程序执行完才会执行下一个程序，这种模式在现如今要求高性能高并发的环境下显然已经是过时的。而在多道程序环境中，程序在并发执行时会有失去封闭性和不可再现的问题，程序的概念已经不适用于多程序并发执行的情况[^注1.1]。由此就引入了“进程”的概念。

​	进程其实就是程序的另一种表达，或者说进程是在多道程序环境（并发环境）下的程序。与进程息息相关的是**进程控制块（Process Control Block，PCB）[^注1.2]**。PCB目的就是为了使程序能够成为在多道程序环境下独立运行的最小单位，成为与其他进程并发执行的进程。

​	进程有程序段、数据段和PCB组成。程序段和数据段是原本存在的，所以说创建进程实质上就是创建PCB，撤销进程实质上就是撤销PCB。

​	有了上述的概念和定义，我们可以简单地用表达式描述进程与程序的关系：**进程 = 程序 + PCB**；



[^注1.1]: 程序只是一组有序指令的集合，并存在某种介质上，其本身并不具备有活动的含义，因而是静态的。可以理解为只是一段代码。在并发环境下，会有间断执行的情况，程序这种静态概念是无法保存现场信息的。
[^注1.2]: PCB对于进程来说是很重要的，在后面篇章会详细介绍

# 进程的特性

​	进程虽然与程序的概念相仿，但就特性而言，它们可以说是截然不同的。

## 动态性

​	动态性是进程最基本的特性。主要表现在：“它由创建而生，由调度而执行，由撤销而消亡”。可见，进程有一定的生命期，而程序就只是一组有序指令的集合。

## 并发性

​	并发性是指多个进程能够同时存于内存中，并且能在一段时间内同时运行。引入进程的目的也正是为了使程序能够与其他程序并发执行。而没有创建PCB的程序是不能作为一个独立的单位参与运行的。

## 独立性

​	在传统的OS中，独立性是指进程是一个能独立运行、独立获得资源和独立接受调度的基本单位。

## 异步性

​	异步性是指进程是按异步方式运行的，即按各自独立的、不可预知的速度向前推进（不是很懂这里的异步，我对此的理解是相对于同步的）。

# 进程的状态

## 基本状态

​	进程的基本状态主要有三种：**执行、就绪和阻塞**。为满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，引入了另外两种状态：**创建和终止**。

- **执行**：指进程已获得CPU，程序正在执行的状态。
- 就绪：指进程已获得除了CPU以外所有运行时必要资源，处于一种准备好运行的状态。处于就绪状态的进程可能会有多个，所以系统通常会以某种策略（如优先级策略）将它们排成一个队列，该队列为“就绪队列”。
- **阻塞**：指正在执行的进程由于发生某些事件（如IO请求，申请缓冲区失败等）暂时无法继续执行时的状态。该状态的进程也会排成一个队列，称为“阻塞队列”。
- **创建**：指进程正在对PCB进行初始化工作及正在获取运行时必要资源（除CPU）时的状态。只要初始化工作和资源获取成功后，就可由创建状态转入就绪状态。引入该状态的目的是确保进程控制块的完整性。操作系统也可以根据系统性能或主存容量的限制推迟进程的创建。
- **终止**：指进程执行完成或被终止时所处的状态。处于终止状态的进程，其PCB可以供其他进程收集利用，一旦无作用后，系统会将该PCB清零，回收其空间。

**状态的转换图：**

![进程状态间的转换图](C:\Users\Administrator\Desktop\学习\操作系统\OS-learn\img\进程状态间的转换图.png)

上图中的 “IO请求” 和 “IO完成” 只是引起阻塞事件的例子，并不是只有IO才能引起阻塞。

## 挂起与激活

​	进程无论处于哪种状态，一旦挂起则会暂停当前的活动，进入静止的状态，无法被调度。挂起对应原语`Suspend`，激活对应原语`Active`。

​	引入挂起的原因是基于系统和用户的需要：

1. **终端用户的需要**。终端用户在程序运行期间发现问题，希望暂停程序，以便研究其执行情况或对程序进行修改。（修BUG，游戏维护等）
2. **父进程请求**。父进程挂起子进程，以便考察和修改该子进程，或者协调各子进程间的活动。
3. **负荷调节的需要**。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统正常运行。
4. **操作系统的需要**。操作系统以便检查运行中的资源使用情况或进行记账，会挂机某些进程。

​	引入挂起后，进程状态中的就绪状态分成了**静止就绪**和**活动就绪**，阻塞状态分成了**静止阻塞**和**活动阻塞**。状态转换图如下：

![引入挂起和激活后的状态转换图](C:\Users\Administrator\Desktop\学习\操作系统\OS-learn\img\引入挂起和激活后的状态转换图.png)

# 进程控制

​	进程控制是进程管理中最基本的功能，主要包括**创建新进程**、**终止已完成的进程**、**将因发生异常情况而无法继续运行的进程置于阻塞状态**、**负责进程运行中的状态转换**等功能。

​	进程控制一般是由OS的内核中的原语来实现的。

## 创建新进程

### 进程的层次结构

​	进程之间也会存在“父子关系”，即进程可以创建进程。有着“父子关系”的进程，子进程可以继承父进程所拥有的资源，继承父进程所分配的缓冲区等。当子进程被撤销时，将其从父进程那里获得的资源归还给父进程；当父进程被撤销时，其子进程及孙子进程也会被撤销。在PCB中的进程标识符会表明该进程的“家族关系”。这种“家族关系“存在与UNIX系统中，在Windows中不存在这种进程层次结构的概念。

​	在Windows中，所有进程都具有相同的地位。如果一个进程创建另外的进程时，创建进程会获得一个句柄，其作用相当于一个令牌，可以用来控制被创建的进程。并且这个句柄是可以进行传递的，即获得了句柄的进程就拥有了控制其它进程的权力，因此进程之间的关系是获得句柄与否、控制与被控制的简单关系。

### 引起创建进程的事件

1. **用户登录**：在分时系统中，用户在终端键入登录命令后，若登录成功，系统将为该用户创建一个进程，并把它插入就绪队列中。
2. **作业调度**：在多道批处理程序中，当作业调度程序按一定的算法调度到某个（些）作业时，便将它（们）装入内存，为它（们）创建进程，并插入就绪队列中。
3. 提供服务：当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务。例如，用户程序要求进行文件打印，操作系统将为它创建一个打印进程，这样不仅可使打印进程与该用户进程并发执行，而且还便于计算打印任务所消耗的时间。
4. **应用请求**：上述三种情况都是系统内核为用户创建新进程。而这种事件则是用户进程自己创建新进程，以便使新进程以同创建者并发运行的方式完成特定任务。例如，某用户进程需要不断地先从键盘终端读入数据，继而再对输入数据进行相应的处理，然后，再将处理结果以表格形式在屏幕显示。该进程为使这几个操作能够并发执行，可以分别建立键盘输入进程、表格输出进程。

### 进程的创建

​	在系统中每当出现了创建新进程的请求后，OS便调用进程创建原语`creat`按以下步骤创建一个新进程：

1. 申请空白PCB，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。
2. 为新进程分配其运行所需的资源，包括各种物理和逻辑资源，如内存、文件、IO设备和CPU时间等。这些资源可以从操作系统或父进程中获得。新进程对这些资源的需求详情一般也要提前告知操作系统或其父进程。
3. 初始化PCB。PCB的初始化包括：**初始化标识信息**，将系统分配的标识符和父进程标识符填入新PCB中；**初始化处理机状态信息**，使程序计数器指向程序的入口地址，使栈指针指向栈顶；**初始化处理机调度信息**，将进程的状态设置为就绪状态或静止就绪状态，对于优先级，通常是将它设置为最低优先级，除非用户以显式的方式提出高优先级要求。
4. 如果进程就绪队列能够容纳新进程，便将新进程插入就绪队列。

## 终止一个进程

### 引起进程终止的事件

1. **正常结束**：进程任务完成，准备退出运行。在任何系统中，都有一个用于表示进程已经运行完成的指示。在批处理系统中，通常会在程序的最后安排一条`Halt`指令，用于向OS表示运行已结束。当程序运行到`Halt`指令时，将产生一个中断，去通知OS本进程已经完成。
2. **异常结束**：常见异常事件有：**越界错**，指进程所访问的存储区域超出该进程的区域；**保护错**，指进程试图去访问一个不允许访问的资源或文件；**非法指令**，指程序试图去执行一个不存在的指令；**特权指令错**，指越权执行OS的指令；**运行超时**，指进程执行时间超过指定的最大值；**等待超时**，指进程等待某事件的时间超过了规定的最大值；**算术运算错**，指进程试图去执行一个被禁止的运算，如被0除；**IO故障**，指在IO过程中发生错误；
3. 外界干预：指进程因外界的请求而终止。这些干预有：**操作员或操作系统干预**，发生某些事件需要终止进程，例如死锁；**父进程请求**，子进程已完成父进程的特定任务，可以提出请求终止该子进程；**父进程终止**，父进程终止，其子进程也应当终止；

### 终止过程

​	如果系统中发生了要求终止进程的某事件，OS便调用进程终止原语，按如下过程终止进程：

1. 根据进程标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态；
2. 若该进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度；
3. 若该进程还有子进程，应将所有子进程都进行终止操作；
4. 将被终止进程所拥有的全部资源归还给系统，或者归还给父进程；
5. 将被终止进程的PCB从所在队列（或链表）[^注4.2.1]中移出，等待其他程序来搜集信息；

[^注4.2.1]:设计PCB的组织方式，即以何种数据结构存储在系统中，后面章节详解

## 进程的阻塞与唤醒

### 引起进程组合和唤醒的事件

1. **进程向系统请求共享资源**：如果请求失败，进程将不能继续执行进而转变成阻塞状态；如果请求成功，进程将被唤醒，转换成就绪状态；例如请求打印机资源；
2. **某种操作**：进程启动某种操作后，如果必须等待该操作完成才能继续执行，进程将被阻塞；某种操作完成后，进程将被唤醒；例如IO操作；
3. **获取数据**：对于相互合作的进程，如果一个进程需要先获得另一进程提供的数据才能继续执行，数据尚未到达时进程将被阻塞；数据到达后，进程将被唤醒；
4. **新任务的到达**：在某些系统中，特别是在网络环境下的OS，往往设置一些特定的系统进程，每当这种进程完成任务后便把自己阻塞起来，等待新任务的到来。例如，在网络环境中的发送进程，其主要任务是发送数据包，若已有的数据包已全部发送完成，而又无新的数据包发送，这时发送进程将把自己阻塞起来；仅当有新的数据包到达时，才将发送进程唤醒；

### 进程阻塞过程

​	正在执行的进程，如果发生上述事件中的阻塞时，就进行如下步骤：

1. 进程通过调用阻塞原语`block`将自己阻塞（阻塞是进程的主动行为）；
2. 调用`block`后，进程立即停止执行，把PCB中的状态由执行改为阻塞，并将PCB插入阻塞队列；
3. 最后转调度程序进行重新调度，保留被阻塞进程的处理机状态（上下文）；

### 进程唤醒过程

​	当被阻塞进程发生上述事件中唤醒时，就进行如下步骤：

1. 由有关进程（比如提供数据的进程）调用唤醒原语`wakeup`，将等待该事件的进程唤醒；
2. 调用`wakeup`后，首先阻塞进程从等待该事件的阻塞队列中移出，将PCB中的状态由阻塞改为就绪；
3. 然后将PCB插入到就绪队列中；

> **！注意：**
>
> `block`原语和`wakeup`原语是一对作用相反的原语。在使用它们时，必须成对使用，否则阻塞进程会因不能被唤醒而永久处于阻塞状态

# 进程同步

​	多道程序并发执行会产生竞态条件的问题。为了避免竞态条件的发生、每次处理结果的不确定性，必须引入进程同步机制。下面介绍单处理机系统的进程同步机制：**硬件同步机制、信号量机制、管程机制**。

## 基本概念

- **间接相互制约关系**：多个进程对**共享系统资源**的争用，对该类资源只能互斥访问，则说多个进程之间存在间接相互制约关系。
- **直接相互制约关系**：两个或多个进程之间，为了共同完成同一项任务相互合作，而在这种合作关系存在直接制约关系。例如，进程A提供数据给进程B进行计算，如果进程A因某种原因一直没提供数据，进程B则会阻塞。
- **临界资源**：属于共享资源的一种，但这种资源一次只允许一个进程使用。如打印机、磁带机等硬件资源就属于临街资源，软件资源的临界资源有消息缓冲队列、全局变量等。也可以说是进程间采用互斥方式访问的资源。
- **临界区**：每个进程中访问临界资源的代码段就被称为**临界区**。在临界区之前需要增加一段用于检查临界资源占用状态的代码段称为**进入区**，在临界区之后用于释放临界资源资源的代码段称为**退出区**。
- **同步机制规则**：
    - 空闲让步：临界资源处于空闲状态时，应允许一个请求进入临界区的进程立即进入自己的临界区。
    - 忙则等待：临街资源处于被占用状态时，试图进入临界区的进程必须等待，保证对临界资源的互斥访问。
    - 有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”。
    - 让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程进入“忙等”。

## 硬件同步机制

​	目前许多计算机已提供一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。利用这些特殊指令就可以解决临界区的问题。

### 关中断

​	关中断主要是在**进入锁测试（进入区）之前关闭中断，直到完成锁测试并上锁之后才能打开中断**。这样，进程在临界区执行期间，计算机系统不响应中断，从而不会引发调度，也就不会发生进程或线程切换。由此，保证了对锁的测试和关锁操作的连续性和完整性，有效地保证了互斥。

​	关中断存在许多问题：

- 滥用关中断权利可能导致严重后果；
- 关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；
- 关中断方法不适用于多CPU系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界区代码。

### Test-and-Set指令

​	**Test-and-Set**是一条硬件指令，利用对一个字的内容进行检测和修正的方式实现互斥访问临界资源。

​	用代码描述（java）如下所示：

```java
// 不考虑值传递和引用传递，只是描述过程
boolean TS(boolean lock) {
	boolean old;
	old = lock;
	lock = false;
	return old;
}
```

​	这条指令的执行过程是不可分割的，即是一条原语。当**lock=FALSE**时，表示资源空闲；当**lock=TRUE**时，表示资源被使用。

​	使用**TS**指令管理临界区时，会为每个临街资源设置一个布尔变量**lock**。

​	利用**TS**指令实现互斥的循环进程结构代码描述（java）如下所示：

```java
do {
	while(TS(lock));
    // do something
	lock = false; // 释放锁
	// ...
} while(true)
```

### Swap指令

​	**swap**指令也是硬件指令，利用交换两个字的内容的方式实现互斥。

​	用代码描述（java）如下所示：

```java
void swap(boolean a, boolean b) {
	boolean tmp;
	tmp = a;
	a = b;
	b = a;
}
```

​	同**TS**指令，使用**swap**也会为每个临界资源设置一个全局的布尔变量lock。

​	利用**swap**指令实现互斥的循环进程代码描述（java）如下所示：

```java
do {
    key = true;
    do {
        swap(lock, key);
    } while(key != false);
    // do something;
    lock = false; // 释放锁
    // ...
}while(true)
```

------

​	通过上述硬件指令的确能有效地实现进程互斥，但它们都存在和自旋锁一样的“忙等”问题，不符合“让权等待”的原则。

## 信号量机制

​	信号量顾名思义，就是通过一个变量实现进程与临界资源之间关于占用状态的通信。进程根据变量表示出的信号判断是否能够进入临界区，并且可以通过变量表示出该进程将退出临界区的信号。

### 整型信号量

​	整型信号量定义为**用于表示资源数目的整型量S**。该整型量只能通过两个标准的**原子操作wait(S)和signal(S)**来访问。这两个操作被分别称为**P、V操作**。

​	P、V操作使用代码描述（java）如下：

```java
void wait(S) {
	while (S <= 0); // 自旋
	S--;
}

void signal(S) {
	S++;
}
```

​	因为两个操作是原子操作，所以它们的执行是不可中断的（wait操作中的自旋和S--也不可中断）。也就是说，S的修改只会在一个进程中发生。

### 记录型信号量

​	整型信号量明显会有“忙等”的问题。记录型信号量通过添加**等待队列**的形式实现“让权等待”，防止“忙等”问题发生。记录型的记录就体现在该等待队列，意指记录被阻塞的进程。

​	代码描述（java）如下所示：

```java
class Semaphore {
	int value;
	List list;
}

void wait (Semaphore S) {
    S.value--;
    if (S.value < 0) block(S.list);
}

void signal (Semaphore S) {
    s.value++;
    if (S.value <= 0) wakeup(s.list);
}
```

- **value** 变量表示系统中某类资源的数目，每次 **wait**操作减少一个；
- **list** 变量表示等待队列。当资源不够时进程自发调用`block`原语进行阻塞，并将PCB插入等待队列；当其他进程调用`wakeup`原语唤醒阻塞进程时，如果队列不为空的话，队列第一个等待的进程将被唤醒；

### AND型信号量

​	前面两个信号量的同步机制都是针对一个临界资源的情况，当进程需要多个临界资源时就可以会产生“死锁”的问题。

​	**AND型信号**与记录型信号量一样通过等待队列遵循“让权等待”的原则，但新增了使用`AND`运算实现针对进程需要访问多个临界资源的情况。**基本思想是：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放**。这样就可以避免“死锁”的发生。

​	代码描述（java）如下所示：

```java
void Swait(S1,S2,...,Sn) {
	while (true) {
        if (Si >= 1 && ... && Sn >= 1) {
            for (int i = 1; i <= n; i++)
                Si--;
            break;
		} else {
            // 只要有一个Si无法获取，就进入等待队列
        }
	}
}

void Ssignal(S1,S2,...,Sn) {
    while (true) {
        for (int i = 1; i <= n; i++) {
            Si++;
            // 将等待队列中所有进程插入就绪队列
        }
    }
}
```

### 信号量集

​	前述的信号量机制都是每次只能对某类临界资源进行**一个单位**的申请或释放，当需要N个单位时，便需要N次P、V操作，这显然是低效的。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于 某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类资源时，在每次分配之前，都必须测试资源的数量，判断是否大于可分配的下限值，决定是否予以分配。

​	信号量集就是可以对多个临界资源的多个单位进行申请或释放的同步机制。对应的**Swait**和**Signal**格式如下：

```java
void Swait(S1, t1, d1, ..., Sn, tn, dn);
void Ssignal(S1, t1, d1, ..., Sn, tn, dn);
```

​	其中 **Si** 表示 **i类资源数量**，**ti** 表示该资源的**分配下限值**（ Si>= ti 时才分配），**di** 表示进程对该资源的**需求值**。

​	一般“信号量集”还有如下几种特殊情况：

1. **Swait(S,d,d)**：此时在信号量集中只有一个信号量，但允许它每次申请 d 个单位的资源，当现有资源数少于d时，不予以分配。
2. **Swait(S,1,1)**：此时的信号量集已退化为一般的记录型信号量（S>1时）或互斥信号量（S=1时）。
3. **Swait(S,1,0)**：这是一种很特殊且很有用的信号量操作。当S>=1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。

## 管程机制

​	信号量机制的同步操作**wait(S)**和**signal(S)**都必须要每个访问临界资源的进程自备，这也就导致大量同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。为了解决这些问题，便产生了新的进程同步工具——管程。

### 管程定义

​	在系统中，可以使用数据结构抽象地描述各种硬件资源和软件资源的资源特性，即用少量信息和对该资源所执行的操作来表示资源，而忽略它们的内部结构和实现细节。因此，可以使用共享数据结构抽象地表示系统中的共享资源，并且对该共享数据结构实施的特定操作定义为一组过程。进程对共享资源的申请、释放和其他操作必须通过这组过程，间接地对共享数据结构实现操作。

​	代表共享资源的**数据结构**以及由对该共享数据结构实施操作的**一组过程**所组成的**资源管理程序**共同构成了一个操作系统的资源管理模块，称之为**管程**。还有一种定义是：一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。

​	由上述的定义可知，管程由四部分组成：

- 管程名称；
- 局部于管程的共享数据结构说明；
- 对共享数据结构进行操作的一组过程；
- 对局部于管程的共享数据结构设置初始值的语句；

​	管程的伪代码描述如下所示：

```c
Monitor monitor_name { 			// 管程名称
	share vriable declarations; // 共享变量说明
    cond declarations; // 条件变量说明
    public:
    	void P1(...){....} // 对数据结构操作的过程
    	void P2(...){....}
    	...
        void Pn(...){...}
    {						 // 管程主体
        initialization code; // 初始化代码
    }
}
```

​	管程包含了面向对象的思想，将数据结构、行为、同步机制都封装在一个对象内部，隐蔽了实现细节。**封装于管程内部的数据结构仅能被封装于管程内部的过程所访问，封装于管程内部的过程也只能访问管程内的数据结构。**

​	在管程机制下，所有进程要访问临界资源必须通过管程间接访问，并且只允许一个进程进入管程，从而实现进程互斥。

​	**管程的特性**：

- **模块化**：管程是一个基本程序单位，可以单独编译；
- **抽象数据结构**：指管程中不仅有数据，而且有对数据的操作；
- **信息隐蔽**：指管程中的数据结构只能被管程中的过程访问，这些过程也是在管程内部定义的，供管程外的进程调用，具体实现外部不可见。

​	**管程与进程的不同点**：

- 进程定义的数据结构是**私有数据结构PCB**，管程定义的是**共享数据结构**；
- 进程操作数据结构是由**顺序程序执行有关操作**，管程主要是进行**同步操作和初始化操作**；
- 进程的目的是**实现系统的并发性**，管程的目的是**解决共享资源的互斥使用问题**；
- 从两者调用关系上看，进程是**主动工作方式**，管程是**被动工作方式**；
- 进程可以并发执行，管程不能与调用者并发；
- 进程具有动态性，管程只是操作系统的一个资源管理模块；

### 条件变量

​	在利用管程实现进程同步时，必须设置同步工具，如两个同步操作原语**wait**和**signal**。当管程“外部”的进程通过管程请求获得临界资源而未能满足时，管程便调用**wait**原语使该进程等待，并将其排在等待队列上。仅当管程“内部”进程访问完成并释放该资源之后，管程才调用**signal**原语，唤醒等待队列中的队首进程。

​	当进程在管程中被阻塞或挂起到进程被唤醒期间，如果进程不释放管程，则其它进程无法进入管程。为了解决这个问题，管程引入了**条件变量**。通常，一个进程被挂机或阻塞的条件可有多个，因此在过程中设置了多个条件变量，对这些**条件变量的访问只能在管程中进行**。

​	管程中对每个条件变量都须予以说明，形式为：**condition x, y;** 对条件变量的操作仅仅是 **wait** 和 **signal**，因此条件变量也是一种抽象数据类型，并且每个条件变量保存了一个链表，用于记录因该条件而阻塞的所有进程，同时提供的两个操作表示为 **x.wait** 和 **x.signal**，其含义为：

- **x.wait**：正在调用管程的进程因 **x条件**需要被阻塞或挂起，则调用 **x.wait**将自己插入到 **x条件的等待队列上**，并释放管程，知道 **x条件变化**。该操作是由被阻塞的进程自发调用；
- **x.signal**：正在调用管程的进程发现 **x条件变化**，则调用 **x.signal**，重新启动一个因 **x条件**而阻塞或挂起的进程，如果**x条件的等待队列**有多个进程，则选择其中的一个；如果没有则继续执行原进程。该操作是由非阻塞进程调用；

​	对于上面的 **x.signal**操作存在一个问题：如果进程Q成功唤醒因**条件x**阻塞的进程P，那么如何决定运行哪个进程呢？

​	可以是进程P等待至进程Q离开管程或被阻塞，也可以是进程Q等待至进程P离开管程或被阻塞。还有一种方法是**规定管程中的过程所执行的 x.signal 操作是过程体的最后一个操作**，这样就不会出现无法决定哪个进程运行的问题。

# 经典进程同步问题

​	问题自行搜索，在这里列出只是用于记忆。

​	**生产者-消费者问题**、**哲学家进餐问题**、**读者-写者问题**。

# 进程通信

待

# PCB

​	在计算机系统中，对于每个资源和每个进程都设置了一个数据结构，用于表征其实体，称之为**资源信息表**或**进程信息表**。这些数据结构一般分为四类：内存表、设备表、文件变和用于进程管理的进程表，通常**进程表又称为进程控制块PCB**。

## 作用

​	**PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位：一个能与其他进程并发执行的进程。**

​	具体作用如下：

- **作为独立运行基本单位的标志**：

    ​	当一个程序配置了PCB后，就表示它已是一个能在多道程序环境下独立运行的、合法的基本单位，也就具有取得OS服务的权利，如打开文件系统中的文件、请求获得IO设备等。系统是通过PCB感知进程存在的，PCB也是进程存在于系统中的唯一标识。（**该作用对应于PCB中的进程标识符**）

    

- **能实现间断性运行方式**：

    ​	在多道程序环境下，程序是采用停停走走间断性的运行方式运行的。当进程因阻塞而停止运行时，它必须保留自己运行时的CPU现场信息，当它再次被调度运行时，还需要恢复其CPU现场信息。如果不保存现场信息，进程每一次重新运行都需要从头开始，这明显是愚蠢的行为。有了PCB后，系统就可将CPU现场信息保存在被中断进程的PCB中，供该进程再次被调度执行时恢复CPU现场使用。（**该作用对应于PCB中的处理机状态**）

    

- **提供进程管理所需要的信息**：

    ​	当调度程序调度到某进程运行时，只能根据该进程PCB中记录的程序和数据在内存或外存中的始址指针，找到相应的程序和数据；在进程运行过程中，当需要访问文件系统的文件或IO设备时，也都需要借助于PCB中的信息。PCB中的资源清单记录了该进程所需的全部资源。可见，在进程的整个生命周期中，OS总是根据PCB实施对进程的控制和管理。（**该作用对应于PCB中的进程调管理信息**）

    

- **提供进程调度所需要的信息**：

    ​	只有处于就绪状态的进程才能被调度执行，而在PCB中就提供了进程处于何种状态的信息。另外，PCB还记录了进程的优先级、等待时间和已执行的时间等与调度有关的信息。（**该作用对应于PCB中的进程调度信息**）

    

- **实现与其它进程的同步与通信**:

    ​	进程同步机制是用于实现诸进程的协调运行的，在采用信号量机制时，它要求在每个进程中都设置有相应的用于同步的信号量。在PCB中还具有用于实现进程通信的区域或通信队列指针等。（**该作用对应于PCB中的进程控制信息**）

## 内容

​	在PCB中，主要包括以下四种内容：

- **进程标识符**：**进程标识符用于唯一标识一个进程**。一个进程通常有两种标识符：

    - **外部标识符**：为了方便用户（进程）对进程的访问，须为每一个进程设置一个外部标识。它是由创建者提供的，通常由字母、数字组成。为了描述进程的家族关系，还应设置父进程标识及子进程标识。此外，还可设置用户标识，以表明拥有该进程的用户。
    - **内部标识符**：为了方便系统对进程的使用，在OS中又为进程设置了内部标识符，即赋予每一个进程唯一的数字标识符，通常是一个进程的序号。

    

- **处理机状态**：**处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的**。处理机处于执行状态时，正在处理的许多信息都是放在寄存器中。当进程被切换时，处理机状态信息（上下文）都必须保存在相应的PCB中，以便在该进程重新执行时能再从断点继续执行。

    这些寄存器包括：

    - **通用寄存器**：又称为用户可视寄存器，它们是用户程序可以访问的，用于暂存信息。
    - **指令计数器**：存放要访问的下一条指令的地址。
    - **程序状态字PSW**：包含状态信息，如条件码、执行方式、中断屏障标志等。
    - **用户栈指针**：指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。

    

- **进程调度信息**：**该内容主要是为了让OS在进行调度时，了解进程的状态及有关进程调度的信息**。

    这些信息有：

    - **进程状态**：指明进程的当前状态。
    - **进程优先级**：用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机。
    - **进程调度所需的其他信息**：该信息与所采用的进程调度算法有关，例如进程等待时间和已执行时间等。
    - **事件**：指进程由执行状态转换成阻塞状态所等待发生的时间，即阻塞原因。

    

- **进程控制信息**：**该内容用于进程控制所必须的信息**。

    包括如下信息：

    - **程序和数据的地址**：保存有进程中的程序和数据在内存或外存中的首地址。
    - **进程同步和通信机制**：实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等，它们可能全部或部分地放在PCB中。
    - **资源清单**：该清单列出了进程在运行期间所需的全部资源（除CPU以外），另外还有一张已分配到该进程的资源清单。
    - **链接指针**：指向本进程（PCB）所在队列的下一个进程的PCB的首地址。

## 组织方式

- **线性方式**：使用线性表存储PCB，地址连续、实现简单、开销小。
- **链接方式**：使用链表存储PCB，可以根据状态分成若干个队列，如就绪队列、阻塞队列等。
- **索引方式**：使用索引表存储指向PCB的地址，索引也可根据状态分为就绪索引、阻塞索引等。

# 线程

​	回看程序、进程、线程的发展历史，我们发现，在**单道程序**OS时，**程序**足够满足当时的执行需求。而后出现了**多道程**序OS时，为了解决在**单处理机环境**下的程序并发执行问题，引入了**进程**的概念。最后为了提高程序并发执行的程度，又提出了**线程**的概念。而线程在**多处理机**系统的发展下，也引用到了各种多处理机OS下。

## 线程的引入

​	引入进程的目的是为了使多个程序能并发执行，以提高资源利用率和系统吞吐量。再引入线程的目的是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。

​	为了解释线程的引入，我们先回想一下进程的两个基本属性：

- 进程是一个**可拥有资源的独立单位**；
- 进程同时是一个**可独立调度和分派的基本单位**；

​	正是由于进程的这两个基本属性，才使进程成为一个能独立运行的基本单位，从而也就构成了进程并发执行的基础。而系统为了使进程能并发执行，必须有这些操作：**创建进程**、**撤销进程**、**进程切换**。这些操作是进程为并发执行所必须的操作（这些操作都与资源和调度有关），也是产生时空开销的源头。

​	如何能使多个程序更好地并发执行，同时又尽量减少系统的开销，正是近年来设计操作系统时所追求的重要目标。有不少研究操作系统的学者们想到，要设法**将进程的上述两个属性分开**，由OS分开处理，亦即并**不把作为调度和分派的基本单位也同时作为拥有资源的单位**，以做到“轻装上阵“；而对于**拥有资源的基本单位**，又**不对之施以频繁的切换**。正式这种思想，形成了线程的概念。

​	传统的进程因为“太重”，致使为实现多处理机环境下的进程的创建、调度、分派，都需要花费较大的时间和空间开销。如果在OS中引入线程，以线程作为调度和分派的基本单位，则可以有效地改善多处理机系统的性能。

​	**个人总结**：

​	线程说白了就是进程在多处理机环境下的另一种形态，就如程序和进程的关系一样。程序“进化”成进程是为了并发执行，进程“进化”成线程是为了提高并发执行的效率。区分线程和进程的概念，其实得从历史角度上看，因为三者都是同一事物在不同时期的概念表达。也就是说单处理机上的进程和多处理机上的进程不是等同的。

## 线程与进程的比较

​	由于线程具有许多传统进程所具有的特征，所有又称为“**轻型进程**”，相应地，传统进程成为“**重型进程**”。下面从调度性、并发性、系统开销和拥有资源等方面对线程和进程进行比较：

- **调度的基本单位**：

    ​	在**传统的OS**中，进程是作为独立调度和分派的基本单位，因而进程是能独立运行的基本单位。在每次被调度时，都**需要进行上下文切换**，开销较大。而在**引入线程的OS**中，已把线程作为调度和分派的基本单位，因而线程是能独立运行的基本单位。当**线程切换时，仅需要保存和设置少量寄存器内容**，切换代价远低于进程。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然会引起进程的切换。

    ​	**引入线程后，线程变成了调度和分派的基本单位。**

- **并发性**：

    ​	在引入线程的OS中，不仅进程之间可以并发执行，而且在同一进程中的多个线程之间也可以并发执行。同样，不同的进程中的线程也能并发执行。这使得OS具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量。

    ​	举个例子说明线程的并发性比进程更好：网络服务器经常收到许多客户请求，如果是传统的单线程的进程来执行该任务，则每次只能为一个客户服务。但如果在一个进程中可以设置多个线程，将其中一个线程专用于监听客户的请求，则每当有一个客户请求时，便立即创建一个线程来处理该客户的请求（网络IO中的IO多路复用）。

    ​	**线程的并发性比进程更好。**

- **拥有资源**：

    ​	**进程是拥有系统资源的基本单位，而线程本身并不拥有系统资源，而是仅有一点能保证独立运行的资源。**例如线程为了能成为独立运行的基本单元，应该具有一个控制线程运行的**线程控制块TCB**，还有一些执行时用于指示指令序列的程序计数器等信息。

    ​	线程除了拥有少量自己的资源外，还可以与同一进程的不同线程共享资源。因为**属于同一进程的所有线程都具有相同的地址空间**，这意味着线程可以访问该地址空间中的每一个虚地址，还可以访问进程所拥有的资源。

- **独立性**：

    ​	**同一进程的不同线程之间的独立性要比不同进程之间的独立性要低得多**。为了防止彼此之间干扰和破坏，每个进程都拥有一个独立的地址空间和其他资源（共享资源除外），不允许其他进程访问。但同一进程的不同线程是为了提高并发性以及进行相互之间的合作而创建的，它们共享进程的内存地址空间和资源，这也是导致同一进程的不同线程之间独立性低的原因。

- **系统开销**：

    ​	在创建或撤销进程时，系统都要为之分配和回收进程控制块、分配或回收其它资源（内存空间等）。而线程因为所需资源很少的原因，其创建或撤销时所付出的开销要低的多。同样在上下切换问题上，线程比进程快得多。由因为同一进程的不同线程具有相同的地址空间，线程之间的通信和同步也比进程简单。甚至在一些OS中，线程的切换、同步和通信都不需要系统内核的干预。

- **支持多处理机系统**：

    ​	在多处理机系统中，传统OS的进程，即单线程进程，不管有多少处理机，该进程只能在一个处理机上运行。但对于多线程进程，就可以将一个进程中的多个线程分配到多个处理机上，使它们并行执行。

    

​	**个人总结**：进程和线程的主要区别在于所需资源问题上，进程因其大量的资源使其变得“肥胖”，而线程所需资源只用在调度和分派上，所以要“轻”很多。在说明两者区别时，可以从该方面进行展开。

## 线程的状态

​	线程与传统进程一样，线程之间也存在共享资源（间接相互制约）和互相合作（直接相互制约）的制约关系，致使线程在运行时也具有间断性。所以线程也有与进程一样的三种进本状态：

- **执行状态**：表示线程已获得处理机而正在运行；
- **就绪状态**：表示线程已具有各种执行条件，只需获得CPU即可运行；
- **阻塞状态**：表示线程在执行时因某事件受阻而处于暂停状态。例如，当一个线程执行需要从键盘读入数据的系统调用时，该线程会阻塞到用户键入。



​	**个人总结**：由此也能看出，线程与传统进程非常相似，也反映了线程其实就是进程在不同系统中的另一种概念（轻型进程）。在引入线程后，调度和分派的基本单位变成了线程，因此线程的状态可以等同于传统进程的状态。

## 线程控制块

​	为使线程能够并发执行，系统也为每个线程配置了一个**线程控制块TCB**，将**所有用于控制和管理线程的信息都记录在线程控制块中**。

​	线程控制块通常有如下内容：

- **线程标识符**：每个线程的唯一标识；
- **一组寄存器**：包括程序计数器PC、状态寄存器和通用寄存器的内容；
- **线程运行状态**：用于描述线程正处于何种运行状态；
- **优先级**：描述线程的优先程度；
- **线程专用存储区**：用于线程切换时存放现场保护信息；
- **信号屏蔽**：即对某些信号加以屏蔽；
- **堆栈指针**：在线程运行时，经常会进行过程调用，而过程的调用通常会出现多重嵌套的情况，这样，就必须将每次过程调用中所使用的局部变量以及返回地址保存起来。为此，应为每个线程设置一个堆栈，用它来保存局部变量和返回地址。相应地，在TCB中，也须设置两个指向堆栈的指针：指向用户自己堆栈的指针和指向核心栈的指针。前者是指当线程运行在用户态时，使用用户自己的用户栈来保存局部变量和返回地址，后者是指当线程运行在核心态时使用系统的核心栈。

## 多线程OS中的进程属性

​	传统进程具有的两个属性，为提高并发性能，已经将其中一个属性“给”了线程，即调度和分派的基本单元。如此，在多线程OS中的进程，已经不再作为一个执行的实体。其属性如下：

- **可拥有资源的基本单位**：在多线程OS中，进程仍是作为系统资源分配的基本单位，任一进程所拥有的资源都包括：**用户的地址空间**、实现进程（线程）间**同步和通信的机制**、**已打开的文件**和**已申请到的IO设备（共享资源）**，以及一张由核心进程维护的**地址映射表**（该表用于实现用户程序的逻辑地址到其内存物理地址的映射）。（相较于传统进程的PCB，少了进程调度相关的资源）
- **多个线程可并发执行**：通常一个进程都含有若干个相对独立的线程。由进程为这些线程提供资源以及运行环境，使它们能并发执行。在OS中的所有线程都只属于某一个特性线程。实际上，现在把传统进程的执行方法称为**单线程方法**。如传统的UNIX系统能支持多用户进程，但只支持单线程方法。反之，将每个进程支持多个线程执行的方法称为**多线程方法**。如java的运行环境是单进程多线程的，Windows2000、Solaris、Mach等采用的则是多进程多线程的方法。
- **进程已不是可执行的实体**：在多线程OS中，是把线程作为独立运行（调度）的基本单位。此时的进程已经不再是一个基本的执行实体。虽然如此，**进程仍具有与执行相关的状态**。例如，所谓进程处于“执行”状态，实际上是指该进程中的某线程正在执行。此外，对进程所施加的与进程相关的操作也对其线程作用。例如，在把某个进程挂起时，该进程中的所有线程也都将被挂起；又如，在把某进程激活时，属于该进程的所有线程也都将被激活。

## 线程的实现

​	

# 参考资料

《计算机操作系统（第四版）》——汤小丹著
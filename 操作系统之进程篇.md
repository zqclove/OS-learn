# 操作系统之进程篇

# 进程定义和概念

​	对于进程的定义，从不同的角度出发会有不同的定义，其中比较典型的是：**进程是系统进行资源分配和调度的一个独立单位。**

​	进程的概念与程序是离不开的。在单道程序环境中，程序在处理器中是顺序执行的，只有当程序执行完才会执行下一个程序，这种模式在现如今要求高性能高并发的环境下显然已经是过时的。而在多道程序环境中，程序在并发执行时会有失去封闭性和不可再现的问题，程序的概念已经不适用于多程序并发执行的情况[^注1.1]。由此就引入了“进程”的概念。

​	进程其实就是程序的另一种表达，或者说进程是在多道程序环境（并发环境）下的程序。与进程息息相关的是**进程控制块（Process Control Block，PCB）[^注1.2]**。PCB目的就是为了使程序能够成为在多道程序环境下独立运行的最小单位，成为与其他进程并发执行的进程。

​	进程有程序段、数据段和PCB组成。程序段和数据段是原本存在的，所以说创建进程实质上就是创建PCB，撤销进程实质上就是撤销PCB。

​	有了上述的概念和定义，我们可以简单地用表达式描述进程与程序的关系：**进程 = 程序 + PCB**；



[^注1.1]: 程序只是一组有序指令的集合，并存在某种介质上，其本身并不具备有活动的含义，因而是静态的。可以理解为只是一段代码。在并发环境下，会有间断执行的情况，程序这种静态概念是无法保存现场信息的。
[^注1.2]: PCB对于进程来说是很重要的，在后面篇章会详细介绍

# 进程的特性

​	进程虽然与程序的概念相仿，但就特性而言，它们可以说是截然不同的。

## 动态性

​	动态性是进程最基本的特性。主要表现在：“它由创建而生，由调度而执行，由撤销而消亡”。可见，进程有一定的生命期，而程序就只是一组有序指令的集合。

## 并发性

​	并发性是指多个进程能够同时存于内存中，并且能在一段时间内同时运行。引入进程的目的也正是为了使程序能够与其他程序并发执行。而没有创建PCB的程序是不能作为一个独立的单位参与运行的。

## 独立性

​	在传统的OS中，独立性是指进程是一个能独立运行、独立获得资源和独立接受调度的基本单位。

## 异步性

​	异步性是指进程是按异步方式运行的，即按各自独立的、不可预知的速度向前推进（不是很懂这里的异步，我对此的理解是相对于同步的）。

# 进程的状态

## 基本状态

​	进程的基本状态主要有三种：**执行、就绪和阻塞**。为满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，引入了另外两种状态：**创建和终止**。

- **执行**：指进程已获得CPU，程序正在执行的状态。
- 就绪：指进程已获得除了CPU以外所有运行时必要资源，处于一种准备好运行的状态。处于就绪状态的进程可能会有多个，所以系统通常会以某种策略（如优先级策略）将它们排成一个队列，该队列为“就绪队列”。
- **阻塞**：指正在执行的进程由于发生某些事件（如IO请求，申请缓冲区失败等）暂时无法继续执行时的状态。该状态的进程也会排成一个队列，称为“阻塞队列”。
- **创建**：指进程正在对PCB进行初始化工作及正在获取运行时必要资源（除CPU）时的状态。只要初始化工作和资源获取成功后，就可由创建状态转入就绪状态。引入该状态的目的是确保进程控制块的完整性。操作系统也可以根据系统性能或主存容量的限制推迟进程的创建。
- **终止**：指进程执行完成或被终止时所处的状态。处于终止状态的进程，其PCB可以供其他进程收集利用，一旦无作用后，系统会将该PCB清零，回收其空间。

**状态的转换图：**

![进程状态间的转换图](C:\Users\Administrator\Desktop\学习\操作系统\OS-learn\img\进程状态间的转换图.png)

上图中的 “IO请求” 和 “IO完成” 只是引起阻塞事件的例子，并不是只有IO才能引起阻塞。

## 挂起与激活

​	进程无论处于哪种状态，一旦挂起则会暂停当前的活动，进入静止的状态，无法被调度。挂起对应原语`Suspend`，激活对应原语`Active`。

​	引入挂起的原因是基于系统和用户的需要：

1. **终端用户的需要**。终端用户在程序运行期间发现问题，希望暂停程序，以便研究其执行情况或对程序进行修改。（修BUG，游戏维护等）
2. **父进程请求**。父进程挂起子进程，以便考察和修改该子进程，或者协调各子进程间的活动。
3. **负荷调节的需要**。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统正常运行。
4. **操作系统的需要**。操作系统以便检查运行中的资源使用情况或进行记账，会挂机某些进程。

​	引入挂起后，进程状态中的就绪状态分成了**静止就绪**和**活动就绪**，阻塞状态分成了**静止阻塞**和**活动阻塞**。状态转换图如下：

![引入挂起和激活后的状态转换图](C:\Users\Administrator\Desktop\学习\操作系统\OS-learn\img\引入挂起和激活后的状态转换图.png)

# 进程控制

​	进程控制是进程管理中最基本的功能，主要包括**创建新进程**、**终止已完成的进程**、**将因发生异常情况而无法继续运行的进程置于阻塞状态**、**负责进程运行中的状态转换**等功能。

​	进程控制一般是由OS的内核中的原语来实现的。

## 创建新进程

### 进程的层次结构

​	进程之间也会存在“父子关系”，即进程可以创建进程。有着“父子关系”的进程，子进程可以继承父进程所拥有的资源，继承父进程所分配的缓冲区等。当子进程被撤销时，将其从父进程那里获得的资源归还给父进程；当父进程被撤销时，其子进程及孙子进程也会被撤销。在PCB中的进程标识符会表明该进程的“家族关系”。这种“家族关系“存在与UNIX系统中，在Windows中不存在这种进程层次结构的概念。

​	在Windows中，所有进程都具有相同的地位。如果一个进程创建另外的进程时，创建进程会获得一个句柄，其作用相当于一个令牌，可以用来控制被创建的进程。并且这个句柄是可以进行传递的，即获得了句柄的进程就拥有了控制其它进程的权力，因此进程之间的关系是获得句柄与否、控制与被控制的简单关系。

### 引起创建进程的事件

1. **用户登录**：在分时系统中，用户在终端键入登录命令后，若登录成功，系统将为该用户创建一个进程，并把它插入就绪队列中。
2. **作业调度**：在多道批处理程序中，当作业调度程序按一定的算法调度到某个（些）作业时，便将它（们）装入内存，为它（们）创建进程，并插入就绪队列中。
3. 提供服务：当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务。例如，用户程序要求进行文件打印，操作系统将为它创建一个打印进程，这样不仅可使打印进程与该用户进程并发执行，而且还便于计算打印任务所消耗的时间。
4. **应用请求**：上述三种情况都是系统内核为用户创建新进程。而这种事件则是用户进程自己创建新进程，以便使新进程以同创建者并发运行的方式完成特定任务。例如，某用户进程需要不断地先从键盘终端读入数据，继而再对输入数据进行相应的处理，然后，再将处理结果以表格形式在屏幕显示。该进程为使这几个操作能够并发执行，可以分别建立键盘输入进程、表格输出进程。

### 进程的创建

​	在系统中每当出现了创建新进程的请求后，OS便调用进程创建原语`creat`按以下步骤创建一个新进程：

1. 申请空白PCB，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。
2. 为新进程分配其运行所需的资源，包括各种物理和逻辑资源，如内存、文件、IO设备和CPU时间等。这些资源可以从操作系统或父进程中获得。新进程对这些资源的需求详情一般也要提前告知操作系统或其父进程。
3. 初始化PCB。PCB的初始化包括：**初始化标识信息**，将系统分配的标识符和父进程标识符填入新PCB中；**初始化处理机状态信息**，使程序计数器指向程序的入口地址，使栈指针指向栈顶；**初始化处理机调度信息**，将进程的状态设置为就绪状态或静止就绪状态，对于优先级，通常是将它设置为最低优先级，除非用户以显式的方式提出高优先级要求。
4. 如果进程就绪队列能够容纳新进程，便将新进程插入就绪队列。

## 终止一个进程

### 引起进程终止的事件

1. **正常结束**：进程任务完成，准备退出运行。在任何系统中，都有一个用于表示进程已经运行完成的指示。在批处理系统中，通常会在程序的最后安排一条`Halt`指令，用于向OS表示运行已结束。当程序运行到`Halt`指令时，将产生一个中断，去通知OS本进程已经完成。
2. **异常结束**：常见异常事件有：**越界错**，指进程所访问的存储区域超出该进程的区域；**保护错**，指进程试图去访问一个不允许访问的资源或文件；**非法指令**，指程序试图去执行一个不存在的指令；**特权指令错**，指越权执行OS的指令；**运行超时**，指进程执行时间超过指定的最大值；**等待超时**，指进程等待某事件的时间超过了规定的最大值；**算术运算错**，指进程试图去执行一个被禁止的运算，如被0除；**IO故障**，指在IO过程中发生错误；
3. 外界干预：指进程因外界的请求而终止。这些干预有：**操作员或操作系统干预**，发生某些事件需要终止进程，例如死锁；**父进程请求**，子进程已完成父进程的特定任务，可以提出请求终止该子进程；**父进程终止**，父进程终止，其子进程也应当终止；

### 终止过程

​	如果系统中发生了要求终止进程的某事件，OS便调用进程终止原语，按如下过程终止进程：

1. 根据进程标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态；
2. 若该进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度；
3. 若该进程还有子进程，应将所有子进程都进行终止操作；
4. 将被终止进程所拥有的全部资源归还给系统，或者归还给父进程；
5. 将被终止进程的PCB从所在队列（或链表）[^注4.2.1]中移出，等待其他程序来搜集信息；

[^注4.2.1]:设计PCB的组织方式，即以何种数据结构存储在系统中，后面章节详解

## 进程的阻塞与唤醒

### 引起进程组合和唤醒的事件

1. **进程向系统请求共享资源**：如果请求失败，进程将不能继续执行进而转变成阻塞状态；如果请求成功，进程将被唤醒，转换成就绪状态；例如请求打印机资源；
2. **某种操作**：进程启动某种操作后，如果必须等待该操作完成才能继续执行，进程将被阻塞；某种操作完成后，进程将被唤醒；例如IO操作；
3. **获取数据**：对于相互合作的进程，如果一个进程需要先获得另一进程提供的数据才能继续执行，数据尚未到达时进程将被阻塞；数据到达后，进程将被唤醒；
4. **新任务的到达**：在某些系统中，特别是在网络环境下的OS，往往设置一些特定的系统进程，每当这种进程完成任务后便把自己阻塞起来，等待新任务的到来。例如，在网络环境中的发送进程，其主要任务是发送数据包，若已有的数据包已全部发送完成，而又无新的数据包发送，这时发送进程将把自己阻塞起来；仅当有新的数据包到达时，才将发送进程唤醒；

### 进程阻塞过程

​	正在执行的进程，如果发生上述事件中的阻塞时，就进行如下步骤：

1. 进程通过调用阻塞原语`block`将自己阻塞（阻塞是进程的主动行为）；
2. 调用`block`后，进程立即停止执行，把PCB中的状态由执行改为阻塞，并将PCB插入阻塞队列；
3. 最后转调度程序进行重新调度，保留被阻塞进程的处理机状态（上下文）；

### 进程唤醒过程

​	当被阻塞进程发生上述事件中唤醒时，就进行如下步骤：

1. 由有关进程（比如提供数据的进程）调用唤醒原语`wakeup`，将等待该事件的进程唤醒；
2. 调用`wakeup`后，首先阻塞进程从等待该事件的阻塞队列中移出，将PCB中的状态由阻塞改为就绪；
3. 然后将PCB插入到就绪队列中；

> **！注意：**
>
> `block`原语和`wakeup`原语是一对作用相反的原语。在使用它们时，必须成对使用，否则阻塞进程会因不能被唤醒而永久处于阻塞状态

# 进程同步

​	多道程序并发执行会产生竞态条件的问题。为了避免竞态条件的发生、每次处理结果的不确定性，必须引入进程同步机制。下面介绍单处理机系统的进程同步机制：**硬件同步机制、信号量机制、管程机制**。

## 基本概念

- **间接相互制约关系**：多个进程对**共享系统资源**的争用，对该类资源只能互斥访问，则说多个进程之间存在间接相互制约关系。
- **直接相互制约关系**：两个或多个进程之间，为了共同完成同一项任务相互合作，而在这种合作关系存在直接制约关系。例如，进程A提供数据给进程B进行计算，如果进程A因某种原因一直没提供数据，进程B则会阻塞。
- **临界资源**：属于共享资源的一种，但这种资源一次只允许一个进程使用。如打印机、磁带机等硬件资源就属于临街资源，软件资源的临界资源有消息缓冲队列、全局变量等。也可以说是进程间采用互斥方式访问的资源。
- **临界区**：每个进程中访问临界资源的代码段就被称为**临界区**。在临界区之前需要增加一段用于检查临界资源占用状态的代码段称为**进入区**，在临界区之后用于释放临界资源资源的代码段称为**退出区**。
- **同步机制规则**：
    - 空闲让步：临界资源处于空闲状态时，应允许一个请求进入临界区的进程立即进入自己的临界区。
    - 忙则等待：临街资源处于被占用状态时，试图进入临界区的进程必须等待，保证对临界资源的互斥访问。
    - 有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”。
    - 让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程进入“忙等”。

## 硬件同步机制

​	目前许多计算机已提供一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。利用这些特殊指令就可以解决临界区的问题。

### 关中断

​	关中断主要是在**进入锁测试（进入区）之前关闭中断，直到完成锁测试并上锁之后才能打开中断**。这样，进程在临界区执行期间，计算机系统不响应中断，从而不会引发调度，也就不会发生进程或线程切换。由此，保证了对锁的测试和关锁操作的连续性和完整性，有效地保证了互斥。

​	关中断存在许多问题：

- 滥用关中断权利可能导致严重后果；
- 关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；
- 关中断方法不适用于多CPU系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界区代码。

### Test-and-Set指令

​	**Test-and-Set**是一条硬件指令，利用对一个字的内容进行检测和修正的方式实现互斥访问临界资源。

​	用代码描述（java）如下所示：

```java
// 不考虑值传递和引用传递，只是描述过程
boolean TS(boolean lock) {
	boolean old;
	old = lock;
	lock = false;
	return old;
}
```

​	这条指令的执行过程是不可分割的，即是一条原语。当**lock=FALSE**时，表示资源空闲；当**lock=TRUE**时，表示资源被使用。

​	使用**TS**指令管理临界区时，会为每个临街资源设置一个布尔变量**lock**。

​	利用**TS**指令实现互斥的循环进程结构代码描述（java）如下所示：

```java
do {
	while(TS(lock));
    // do something
	lock = false; // 释放锁
	// ...
} while(true)
```

### Swap指令

​	**swap**指令也是硬件指令，利用交换两个字的内容的方式实现互斥。

​	用代码描述（java）如下所示：

```java
void swap(boolean a, boolean b) {
	boolean tmp;
	tmp = a;
	a = b;
	b = a;
}
```

​	同**TS**指令，使用**swap**也会为每个临界资源设置一个全局的布尔变量lock。

​	利用**swap**指令实现互斥的循环进程代码描述（java）如下所示：

```java
do {
    key = true;
    do {
        swap(lock, key);
    } while(key != false);
    // do something;
    lock = false; // 释放锁
    // ...
}while(true)
```

------

​	通过上述硬件指令的确能有效地实现进程互斥，但它们都存在和自旋锁一样的“忙等”问题，不符合“让权等待”的原则。

## 信号量机制

​	信号量顾名思义，就是通过一个变量实现进程与临界资源之间关于占用状态的通信。进程根据变量表示出的信号判断是否能够进入临界区，并且可以通过变量表示出该进程将退出临界区的信号。

### 整型信号量

​	整型信号量定义为**用于表示资源数目的整型量S**。该整型量只能通过两个标准的**原子操作wait(S)和signal(S)**来访问。这两个操作被分别称为**P、V操作**。

​	P、V操作使用代码描述（java）如下：

```java
void wait(S) {
	while (S <= 0); // 自旋
	S--;
}

void signal(S) {
	S++;
}
```

​	因为两个操作是原子操作，所以它们的执行是不可中断的（wait操作中的自旋和S--也不可中断）。也就是说，S的修改只会在一个进程中发生。

### 记录型信号量

​	整型信号量明显会有“忙等”的问题。记录型信号量通过添加**等待队列**的形式实现“让权等待”，防止“忙等”问题发生。记录型的记录就体现在该等待队列，意指记录被阻塞的进程。

​	代码描述（java）如下所示：

```java
class Semaphore {
	int value;
	List list;
}

void wait (Semaphore S) {
    S.value--;
    if (S.value < 0) block(S.list);
}

void signal (Semaphore S) {
    s.value++;
    if (S.value <= 0) wakeup(s.list);
}
```

- **value** 变量表示系统中某类资源的数目，每次 **wait**操作减少一个；
- **list** 变量表示等待队列。当资源不够时进程自发调用`block`原语进行阻塞，并将PCB插入等待队列；当其他进程调用`wakeup`原语唤醒阻塞进程时，如果队列不为空的话，队列第一个等待的进程将被唤醒；

### AND型信号量

​	前面两个信号量的同步机制都是针对一个临界资源的情况，当进程需要多个临界资源时就可以会产生“死锁”的问题。

​	**AND型信号**与记录型信号量一样通过等待队列遵循“让权等待”的原则，但新增了使用`AND`运算实现针对进程需要访问多个临界资源的情况。**基本思想是：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放**。这样就可以避免“死锁”的发生。

​	代码描述（java）如下所示：

```java
void Swait(S1,S2,...,Sn) {
	while (true) {
        if (Si >= 1 && ... && Sn >= 1) {
            for (int i = 1; i <= n; i++)
                Si--;
            break;
		} else {
            // 只要有一个Si无法获取，就进入等待队列
        }
	}
}

void Ssignal(S1,S2,...,Sn) {
    while (true) {
        for (int i = 1; i <= n; i++) {
            Si++;
            // 将等待队列中所有进程插入就绪队列
        }
    }
}
```

### 信号量集

​	前述的信号量机制都是每次只能对某类临界资源进行**一个单位**的申请或释放，当需要N个单位时，便需要N次P、V操作，这显然是低效的。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于 某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类资源时，在每次分配之前，都必须测试资源的数量，判断是否大于可分配的下限值，决定是否予以分配。

​	信号量集就是可以对多个临界资源的多个单位进行申请或释放的同步机制。对应的**Swait**和**Signal**格式如下：

```java
void Swait(S1, t1, d1, ..., Sn, tn, dn);
void Ssignal(S1, t1, d1, ..., Sn, tn, dn);
```

​	其中 **Si** 表示 **i类资源数量**，**ti** 表示该资源的**分配下限值**（ Si>= ti 时才分配），**di** 表示进程对该资源的**需求值**。

​	一般“信号量集”还有如下几种特殊情况：

1. **Swait(S,d,d)**：此时在信号量集中只有一个信号量，但允许它每次申请 d 个单位的资源，当现有资源数少于d时，不予以分配。
2. **Swait(S,1,1)**：此时的信号量集已退化为一般的记录型信号量（S>1时）或互斥信号量（S=1时）。
3. **Swait(S,1,0)**：这是一种很特殊且很有用的信号量操作。当S>=1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。

## 管程机制

​	信号量机制的同步操作**wait(S)**和**signal(S)**都必须要每个访问临界资源的进程自备，这也就导致大量同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。为了解决这些问题，便产生了新的进程同步工具——管程。

### 管程定义

​	在系统中，可以使用数据结构抽象地描述各种硬件资源和软件资源的资源特性，即用少量信息和对该资源所执行的操作来表示资源，而忽略它们的内部结构和实现细节。因此，可以使用共享数据结构抽象地表示系统中的共享资源，并且对该共享数据结构实施的特定操作定义为一组过程。进程对共享资源的申请、释放和其他操作必须通过这组过程，间接地对共享数据结构实现操作。

​	代表共享资源的**数据结构**以及由对该共享数据结构实施操作的**一组过程**所组成的**资源管理程序**共同构成了一个操作系统的资源管理模块，称之为**管程**。还有一种定义是：一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。

​	由上述的定义可知，管程由四部分组成：

- 管程名称；
- 局部于管程的共享数据结构说明；
- 对共享数据结构进行操作的一组过程；
- 对局部于管程的共享数据结构设置初始值的语句；

​	管程的伪代码描述如下所示：

```c
Monitor monitor_name { 			// 管程名称
	share vriable declarations; // 共享变量说明
    cond declarations; // 条件变量说明
    public:
    	void P1(...){....} // 对数据结构操作的过程
    	void P2(...){....}
    	...
        void Pn(...){...}
    {						 // 管程主体
        initialization code; // 初始化代码
    }
}
```

​	管程包含了面向对象的思想，将数据结构、行为、同步机制都封装在一个对象内部，隐蔽了实现细节。**封装于管程内部的数据结构仅能被封装于管程内部的过程所访问，封装于管程内部的过程也只能访问管程内的数据结构。**

​	在管程机制下，所有进程要访问临界资源必须通过管程间接访问，并且只允许一个进程进入管程，从而实现进程互斥。

​	**管程的特性**：

- **模块化**：管程是一个基本程序单位，可以单独编译；
- **抽象数据结构**：指管程中不仅有数据，而且有对数据的操作；
- **信息隐蔽**：指管程中的数据结构只能被管程中的过程访问，这些过程也是在管程内部定义的，供管程外的进程调用，具体实现外部不可见。

​	**管程与进程的不同点**：

- 进程定义的数据结构是**私有数据结构PCB**，管程定义的是**共享数据结构**；
- 进程操作数据结构是由**顺序程序执行有关操作**，管程主要是进行**同步操作和初始化操作**；
- 进程的目的是**实现系统的并发性**，管程的目的是**解决共享资源的互斥使用问题**；
- 从两者调用关系上看，进程是**主动工作方式**，管程是**被动工作方式**；
- 进程可以并发执行，管程不能与调用者并发；
- 进程具有动态性，管程只是操作系统的一个资源管理模块；

### 条件变量

​	在利用管程实现进程同步时，必须设置同步工具，如两个同步操作原语**wait**和**signal**。当管程“外部”的进程通过管程请求获得临界资源而未能满足时，管程便调用**wait**原语使该进程等待，并将其排在等待队列上。仅当管程“内部”进程访问完成并释放该资源之后，管程才调用**signal**原语，唤醒等待队列中的队首进程。

​	当进程在管程中被阻塞或挂起到进程被唤醒期间，如果进程不释放管程，则其它进程无法进入管程。为了解决这个问题，管程引入了**条件变量**。通常，一个进程被挂机或阻塞的条件可有多个，因此在过程中设置了多个条件变量，对这些**条件变量的访问只能在管程中进行**。

​	管程中对每个条件变量都须予以说明，形式为：**condition x, y;** 对条件变量的操作仅仅是 **wait** 和 **signal**，因此条件变量也是一种抽象数据类型，并且每个条件变量保存了一个链表，用于记录因该条件而阻塞的所有进程，同时提供的两个操作表示为 **x.wait** 和 **x.signal**，其含义为：

- **x.wait**：正在调用管程的进程因 **x条件**需要被阻塞或挂起，则调用 **x.wait**将自己插入到 **x条件的等待队列上**，并释放管程，知道 **x条件变化**。该操作是由被阻塞的进程自发调用；
- **x.signal**：正在调用管程的进程发现 **x条件变化**，则调用 **x.signal**，重新启动一个因 **x条件**而阻塞或挂起的进程，如果**x条件的等待队列**有多个进程，则选择其中的一个；如果没有则继续执行原进程。该操作是由非阻塞进程调用；

​	对于上面的 **x.signal**操作存在一个问题：如果进程Q成功唤醒因**条件x**阻塞的进程P，那么如何决定运行哪个进程呢？

​	可以是进程P等待至进程Q离开管程或被阻塞，也可以是进程Q等待至进程P离开管程或被阻塞。还有一种方法是**规定管程中的过程所执行的 x.signal 操作是过程体的最后一个操作**，这样就不会出现无法决定哪个进程运行的问题。

# PCB

​	

# 参考资料

《计算机操作系统（第四版）》——汤小丹著
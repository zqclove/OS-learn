# 操作系统之进程篇

# 进程定义和概念

​	对于进程的定义，从不同的角度出发会有不同的定义，其中比较典型的是：**进程是系统进行资源分配和调度的一个独立单位。**

​	进程的概念与程序是离不开的。在单道程序环境中，程序在处理器中是顺序执行的，只有当程序执行完才会执行下一个程序，这种模式在现如今要求高性能高并发的环境下显然已经是过时的。而在多道程序环境中，程序在并发执行时会有失去封闭性和不可再现的问题，程序的概念已经不适用于多程序并发执行的情况[^注1.1]。由此就引入了“进程”的概念。

​	进程其实就是程序的另一种表达，或者说进程是在多道程序环境（并发环境）下的程序。与进程息息相关的是**进程控制块（Process Control Block，PCB）[^注1.2]**。PCB目的就是为了使程序能够成为在多道程序环境下独立运行的最小单位，成为与其他进程并发执行的进程。

​	进程有程序段、数据段和PCB组成。程序段和数据段是原本存在的，所以说创建进程实质上就是创建PCB，撤销进程实质上就是撤销PCB。

​	有了上述的概念和定义，我们可以简单地用表达式描述进程与程序的关系：**进程 = 程序 + PCB**；



[^注1.1]: 程序只是一组有序指令的集合，并存在某种介质上，其本身并不具备有活动的含义，因而是静态的。可以理解为只是一段代码。在并发环境下，会有间断执行的情况，程序这种静态概念是无法保存现场信息的。
[^注1.2]: PCB对于进程来说是很重要的，在后面篇章会详细介绍

# 进程的特性

​	进程虽然与程序的概念相仿，但就特性而言，它们可以说是截然不同的。

## 动态性

​	动态性是进程最基本的特性。主要表现在：“它由创建而生，由调度而执行，由撤销而消亡”。可见，进程有一定的生命期，而程序就只是一组有序指令的集合。

## 并发性

​	并发性是指多个进程能够同时存于内存中，并且能在一段时间内同时运行。引入进程的目的也正是为了使程序能够与其他程序并发执行。而没有创建PCB的程序是不能作为一个独立的单位参与运行的。

## 独立性

​	在传统的OS中，独立性是指进程是一个能独立运行、独立获得资源和独立接受调度的基本单位。

## 异步性

​	异步性是指进程是按异步方式运行的，即按各自独立的、不可预知的速度向前推进（不是很懂这里的异步，我对此的理解是相对于同步的）。

# 进程的状态

## 基本状态

​	进程的基本状态主要有三种：**执行、就绪和阻塞**。为满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，引入了另外两种状态：**创建和终止**。

- **执行**：指进程已获得CPU，程序正在执行的状态。
- 就绪：指进程已获得除了CPU以外所有运行时必要资源，处于一种准备好运行的状态。处于就绪状态的进程可能会有多个，所以系统通常会以某种策略（如优先级策略）将它们排成一个队列，该队列为“就绪队列”。
- **阻塞**：指正在执行的进程由于发生某些事件（如IO请求，申请缓冲区失败等）暂时无法继续执行时的状态。该状态的进程也会排成一个队列，称为“阻塞队列”。
- **创建**：指进程正在对PCB进行初始化工作及正在获取运行时必要资源（除CPU）时的状态。只要初始化工作和资源获取成功后，就可由创建状态转入就绪状态。引入该状态的目的是确保进程控制块的完整性。操作系统也可以根据系统性能或主存容量的限制推迟进程的创建。
- **终止**：指进程执行完成或被终止时所处的状态。处于终止状态的进程，其PCB可以供其他进程收集利用，一旦无作用后，系统会将该PCB清零，回收其空间。

**状态的转换图：**

![进程状态间的转换图](C:\Users\Administrator\Desktop\学习\操作系统\OS-learn\img\进程状态间的转换图.png)

上图中的 “IO请求” 和 “IO完成” 只是引起阻塞事件的例子，并不是只有IO才能引起阻塞。

## 挂起与激活

​	进程无论处于哪种状态，一旦挂起则会暂停当前的活动，进入静止的状态，无法被调度。挂起对应原语`Suspend`，激活对应原语`Active`。

​	引入挂起的原因是基于系统和用户的需要：

1. **终端用户的需要**。终端用户在程序运行期间发现问题，希望暂停程序，以便研究其执行情况或对程序进行修改。（修BUG，游戏维护等）
2. **父进程请求**。父进程挂起子进程，以便考察和修改该子进程，或者协调各子进程间的活动。
3. **负荷调节的需要**。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统正常运行。
4. **操作系统的需要**。操作系统以便检查运行中的资源使用情况或进行记账，会挂机某些进程。

​	引入挂起后，进程状态中的就绪状态分成了**静止就绪**和**活动就绪**，阻塞状态分成了**静止阻塞**和**活动阻塞**。状态转换图如下：

![引入挂起和激活后的状态转换图](C:\Users\Administrator\Desktop\学习\操作系统\OS-learn\img\引入挂起和激活后的状态转换图.png)

# 进程控制

​	进程控制是进程管理中最基本的功能，主要包括**创建新进程**、**终止已完成的进程**、**将因发生异常情况而无法继续运行的进程置于阻塞状态**、**负责进程运行中的状态转换**等功能。

​	进程控制一般是由OS的内核中的原语来实现的。

## 创建新进程

### 进程的层次结构

​	进程之间也会存在“父子关系”，即进程可以创建进程。有着“父子关系”的进程，子进程可以继承父进程所拥有的资源，继承父进程所分配的缓冲区等。当子进程被撤销时，将其从父进程那里获得的资源归还给父进程；当父进程被撤销时，其子进程及孙子进程也会被撤销。在PCB中的进程标识符会表明该进程的“家族关系”。这种“家族关系“存在与UNIX系统中，在Windows中不存在这种进程层次结构的概念。

​	在Windows中，所有进程都具有相同的地位。如果一个进程创建另外的进程时，创建进程会获得一个句柄，其作用相当于一个令牌，可以用来控制被创建的进程。并且这个句柄是可以进行传递的，即获得了句柄的进程就拥有了控制其它进程的权力，因此进程之间的关系是获得句柄与否、控制与被控制的简单关系。

### 引起创建进程的事件

1. **用户登录**：在分时系统中，用户在终端键入登录命令后，若登录成功，系统将为该用户创建一个进程，并把它插入就绪队列中。
2. **作业调度**：在多道批处理程序中，当作业调度程序按一定的算法调度到某个（些）作业时，便将它（们）装入内存，为它（们）创建进程，并插入就绪队列中。
3. 提供服务：当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务。例如，用户程序要求进行文件打印，操作系统将为它创建一个打印进程，这样不仅可使打印进程与该用户进程并发执行，而且还便于计算打印任务所消耗的时间。
4. **应用请求**：上述三种情况都是系统内核为用户创建新进程。而这种事件则是用户进程自己创建新进程，以便使新进程以同创建者并发运行的方式完成特定任务。例如，某用户进程需要不断地先从键盘终端读入数据，继而再对输入数据进行相应的处理，然后，再将处理结果以表格形式在屏幕显示。该进程为使这几个操作能够并发执行，可以分别建立键盘输入进程、表格输出进程。

### 进程的创建

​	在系统中每当出现了创建新进程的请求后，OS便调用进程创建原语`creat`按以下步骤创建一个新进程：

1. 申请空白PCB，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。
2. 为新进程分配其运行所需的资源，包括各种物理和逻辑资源，如内存、文件、IO设备和CPU时间等。这些资源可以从操作系统或父进程中获得。新进程对这些资源的需求详情一般也要提前告知操作系统或其父进程。
3. 初始化PCB。PCB的初始化包括：**初始化标识信息**，将系统分配的标识符和父进程标识符填入新PCB中；**初始化处理机状态信息**，使程序计数器指向程序的入口地址，使栈指针指向栈顶；**初始化处理机调度信息**，将进程的状态设置为就绪状态或静止就绪状态，对于优先级，通常是将它设置为最低优先级，除非用户以显式的方式提出高优先级要求。
4. 如果进程就绪队列能够容纳新进程，便将新进程插入就绪队列。

## 终止一个进程

### 引起进程终止的事件

1. **正常结束**：进程任务完成，准备退出运行。在任何系统中，都有一个用于表示进程已经运行完成的指示。在批处理系统中，通常会在程序的最后安排一条`Halt`指令，用于向OS表示运行已结束。当程序运行到`Halt`指令时，将产生一个中断，去通知OS本进程已经完成。
2. **异常结束**：常见异常事件有：**越界错**，指进程所访问的存储区域超出该进程的区域；**保护错**，指进程试图去访问一个不允许访问的资源或文件；**非法指令**，指程序试图去执行一个不存在的指令；**特权指令错**，指越权执行OS的指令；**运行超时**，指进程执行时间超过指定的最大值；**等待超时**，指进程等待某事件的时间超过了规定的最大值；**算术运算错**，指进程试图去执行一个被禁止的运算，如被0除；**IO故障**，指在IO过程中发生错误；
3. 外界干预：指进程因外界的请求而终止。这些干预有：**操作员或操作系统干预**，发生某些事件需要终止进程，例如死锁；**父进程请求**，子进程已完成父进程的特定任务，可以提出请求终止该子进程；**父进程终止**，父进程终止，其子进程也应当终止；

### 终止过程

​	如果系统中发生了要求终止进程的某事件，OS便调用进程终止原语，按如下过程终止进程：

1. 根据进程标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态；
2. 若该进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度；
3. 若该进程还有子进程，应将所有子进程都进行终止操作；
4. 将被终止进程所拥有的全部资源归还给系统，或者归还给父进程；
5. 将被终止进程的PCB从所在队列（或链表）[^注4.2.1]中移出，等待其他程序来搜集信息；

[^注4.2.1]:设计PCB的组织方式，即以何种数据结构存储在系统中，后面章节详解

## 进程的阻塞与唤醒

### 引起进程组合和唤醒的事件

1. **进程向系统请求共享资源**：如果请求失败，进程将不能继续执行进而转变成阻塞状态；如果请求成功，进程将被唤醒，转换成就绪状态；例如请求打印机资源；
2. **某种操作**：进程启动某种操作后，如果必须等待该操作完成才能继续执行，进程将被阻塞；某种操作完成后，进程将被唤醒；例如IO操作；
3. **获取数据**：对于相互合作的进程，如果一个进程需要先获得另一进程提供的数据才能继续执行，数据尚未到达时进程将被阻塞；数据到达后，进程将被唤醒；
4. **新任务的到达**：在某些系统中，特别是在网络环境下的OS，往往设置一些特定的系统进程，每当这种进程完成任务后便把自己阻塞起来，等待新任务的到来。例如，在网络环境中的发送进程，其主要任务是发送数据包，若已有的数据包已全部发送完成，而又无新的数据包发送，这时发送进程将把自己阻塞起来；仅当有新的数据包到达时，才将发送进程唤醒；

### 进程阻塞过程

​	正在执行的进程，如果发生上述事件中的阻塞时，就进行如下步骤：

1. 进程通过调用阻塞原语`block`将自己阻塞（阻塞是进程的主动行为）；
2. 调用`block`后，进程立即停止执行，把PCB中的状态由执行改为阻塞，并将PCB插入阻塞队列；
3. 最后转调度程序进行重新调度，保留被阻塞进程的处理机状态（上下文）；

### 进程唤醒过程

​	当被阻塞进程发生上述事件中唤醒时，就进行如下步骤：

1. 由有关进程（比如提供数据的进程）调用唤醒原语`wakeup`，将等待该事件的进程唤醒；
2. 调用`wakeup`后，首先阻塞进程从等待该事件的阻塞队列中移出，将PCB中的状态由阻塞改为就绪；
3. 然后将PCB插入到就绪队列中；

> **！注意：**
>
> `block`原语和`wakeup`原语是一对作用相反的原语。在使用它们时，必须成对使用，否则阻塞进程会因不能被唤醒而永久处于阻塞状态

# 进程同步



# PCB



# 参考资料

《计算机操作系统（第四版）》——汤小丹著
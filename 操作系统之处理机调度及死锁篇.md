# 处理机调度的层次和调度算法的目标

​	调度的实质是一种资源分配，处理机调度是对处理机资源进行分配。处理机调度算法是指根据处理机分配策略所规定的处理机资源分配算法。

## 处理机调度的层次

- **高级调度**：

    ​	高级调度又称长程调度或**作业调度**，它的**调度对象是作业**。主要功能是根据某种算法，**决定将 外存 上处于后备队列中的哪几个作业调入 内存，为它们创建进程、分配必要的资源，并将它们放入就绪队列**。高级调度主要用于多道批处理系统中，而在分时和实时系统中不设置高级调度。

- **中级调度**：

    ​	中级调度又称为**内存调度**。引入中级调度的**目的是提高内存利用率和系统吞吐量**。主要功能是**把暂时不能运行的进程调至外存等待**，此时进程的状态为**就绪外存状态**（或挂起状态）。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把**外存上的已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态，放入就绪队列中**。中级调度实际上就是存储器管理中的对换功能，会在存储器管理篇详细介绍。

- **低级调度**：

    ​	低级调度又称为短程调度或**进程调度**，它的调度对象是进程（或内核级线程）。其主要功能是根据某种算法，**决定就绪队列中的哪个进程应该获得处理机，并由分派程序将处理机分配给选中的进程**。进程调度是最基本的一种调度，很多系统都配置这级调度。 

​	上述三种调度中，进程调度的运行频率最高，内存调度次之，作业调度最低。进程调度运行频繁且时间短，因此称为短程调度，为避免调度程序本身占有太多CPU时间，进程调度算法不应太复杂。作业调度运行周期长且时间长，因此称为长程调度。内存调度介于两种调度之间，因此称为中程调度。

​	**个人总结**：从进程状态上看，高级调度是与新进程的调度有关，中级调度与挂起进程有关，低级调度与就绪进程有关；从存储器上看，高级调度和中级调度都与内存和外存有关，低级调度与内存（就绪队列）有关。**低级调度决定哪些进程获得处理机资源**，中级调度与高级调度决定哪些进程进入就绪队列。

## 调度算法的目标

​	一般来说，调度算法和方式很大程度取决于操作系统的类型及其设计目标。在批处理系统、分时心痛和实时系统中，通常都采用不同的调度方式和算法。

### 处理机调度算法的共同目标

- **资源利用率**：

    ​	尽可能使系统中的处理机和其他所有资源都保持忙碌状态。

    ​	CPU利用率计算方法：
    $$
    CPU的利用率=（CPU有效工作时间）/（CPU有效工作时间 + CPU空闲时间）
    $$

- **公平性**：

    ​	指**应使各个进程都获得合理的CPU时间，不会发生进程“饥饿现象”**。公平性是相对的，对相同类型的进程应获得相同的服务；但对于不同类型的进程，由于其紧急程度或重要性的不同，则应提供不同的服务。

- **平衡性**：

    ​	由于在系统中具有多种类型的进程，有的属于计算型作业，有的属于IO型。为使系统中的CPU和各种外部设备都能经常处于忙碌状态，调度算法应尽可能保持系统资源使用的平衡性。

- **策略强制执行**：

    ​	对所制订的策略其中包括安全策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟也要执行。

### 批处理系统的目标

- **平均周转时间短**：

    ​	周转时间是**指从作业被提交给系统开始，到作业完成为止的这段时间间隔**（称为作业周转时间）。它包括四部分时间：**作业在外存后备队列上等待作业调度的时间**、**进程在就绪队列上等待进程调度的时间**、**进程在CPU上执行的时间**、**进程等待IO操作完成的时间**。其中后三项在一个作业的整个处理过程中，可能发生多次。

- **系统吞吐量高**：

    ​	吞吐量是**指在单位时间内系统所完成的作业数**。因此它与批处理作业的平均长度有关，如果为了提高系统吞吐量，就应尽量地多选择短作业运行。

- **处理机利用率高**：

    ​	对于大、中型计算机，CPU价格十分昂贵，致使处理机的利用率成为衡量系统性能的十分重要的指标；而调度方式和算法又对处理机的利用率起着十分重要的作用。如果但是为使处理机利用率高，应尽量多地选择计算量打的作业运行。有上述可以看出，这些要求之间是存在着一定矛盾的。

### 分时系统的目标

- **响应时间快**：

    ​	响应时间快是选择分时系统中**进程调度算法的重要准则**。响应时间是指从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为止的一段时间间隔。它包括三部分时间：

    - 请求信息从键盘输入开始，直至将其传送到处理机的时间；
    - 处理机对请求信息进行处理的时间；
    - 将所形成的响应信息回送到终端显示器的时间；

- **均衡性**：

    ​	用户对响应时间的要求并非完全相同。通常用户对较复杂任务的响应时间允许较长，而对简单任务的响应时间则要短。所谓均衡性，是**指系统响应时间的快慢应与用户所请求服务的复杂性相适应**。

### 实时系统的目标

- **截止时间的保证**：

    ​	截止时间是**指某任务必须开始执行的最迟时间，或必须完成的最迟时间**。对于严格的实时系统，其调度方式和调度算法必须能保证这一点，否则将可能造成难以预料的后果。对于实时系统而言，调度算法的一个主要目标是保证实时任务对截止时间的要求。对于HRT任务，其调度方式和调度算法必须确保截止时间的要求，否则将可能造成难以预料的后果；而对于SRT任务，其调度方式和调度算法也应基本上能保证对截止时间的要求。

- **可预测性**：

    ​	在实时系统中，可预测性显得非常重要。例如，在多媒体系统中，无论是电影还是电视剧都应是连续播放的，这就提供了请求的可预测性。

# 作业与作业调度

​	在多道批处理系统中，作业是用户提交给系统的一项相对独立的**工作**。操作员把用户提交的作业通过相应的输入设备输入到磁盘存储器，并保存在一个后备作业队列中，再由作业调度程序将其从外存调入内存。

## 批处理系统中的作业

- **作业和作业步**：

    - **作业**：作业是一个**比程序更为广泛的概念**，它不仅包含了通常的程序和数据，而且还应配有一份**作业说明书**，系统根据该说明书来对程序的运行进行控制。在批处理系统中，是以作业为基本单位从外存调入内存的。
    - **作业步**：通常，在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。我们把其中的**每一个加工步骤称为一个作业步**，各作业步之间存在着相互关系，往往是上一个作业步的输出作为下一个作业步的输入。例如，一个典型的作业可分为：”编译“作业步，”链接装配“作业步和”运行“作业步。

- **作业控制块**：

    ​	为了管理和调度作业，会为每个作业设置一个作业控制块 JCB，是作业在系统存在的标志，保存了管理和调度所需的全部信息。通常 JCB中包含有：作业标识、用户名称、用户账号、**作业类型**（IO繁忙型、CPU繁忙型、批量型、终端型）、**作业状态**、调度信息、资源需求、资源使用情况等。

- **作业运行的三个阶段和三种状态**：

    ​	作业从进入系统到运行结束，通常需要经历收容、运行和完成三个阶段。相应的作业也就有“后备状态”、“运行状态”和“完成状态”。

    - 收容阶段：操作员把用户提交的作业通过某种输入方式或SPOOLing系统输入到硬盘上，再为该作业创建 JCB，并把它放入作业后备队列中。此时的作业为”后备状态“；
    - 运行阶段：当作业被作业调度选中后，便为它分配必要的资源和建立进程，并将它放入就绪队列。一个作业从第一次进入就绪状态开始，直到它运行结束前，在此期间都处于”运行状态“；
    - 完成阶段：当作业运行完成、或发生异常情况而提前结束时，作业便进入完成阶段，相应的作业状态为”完成状态“。此时系统中的”终止作业“程序将会回收已分配给该作业的作业控制块和所有资源，并将作业运行结果信息形成输出文件后输出。

## 先来先服务和短作业优先调度算法

- **先来先服务（first-come first-served，FCFS）**：

    ​	FCFS是最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。该算法中，系统将按照作业到达的**先后次序**来进行调度，或者说它是优先考虑在系统中等待时间最长的作业，而不管该作业所需执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程，然后放入就绪队列。

    ​	FCFS并不是一个很好的算法，但经常把它与其它调度算法相结合使用，形成一种更为有效的调度算法。

- **短作业优先（short job frist，SJF）**：

    ​	因为实际情况中，短作业占有很大比例，为了使它们能比长作业优先执行，而产生了短作业优先调度算法。该算法就如名字一般，作业越短，优先级越高。作业的长短是以作业所要求的运行时间来衡量的，所以运行时间越短的作业优先调入内存运行。

    ​	SJF算法缺点也很多：必须预知作业的运行时间；对长作业非常不利；使用该算法无法实现人机交互；紧迫作业不能及时处理。

## 优先级调度算法和高响应比优先调度算法

- **优先级调度算法（priority-scheduling algorithm，PSA）**：

    ​	在优先级调度算法中，是基于**作业的紧迫程度**，由外部赋予作业相应的优先级，调度算法是根据该优先级进行调度的。这样就可以保证紧迫性作业优先运行。优先级调度算法可作为作业调度算法，也可作为进程调度算法。使用该算法时，系统会从后备队列中选择若干个优先级最高的作业装入内存。

- **高响应比优先调度算法（highest response ratio next，HRRN）**：

    ​	HRRN调度算法是既考虑作业的等待时间，又考虑作业运行时间的调度算法，因此既照顾了短作业，又不致使长作业的等待时间过长，从而改善了处理机调度的性能。

    ​	在该算法中，会为每个作业引入一个**动态优先级**，即优先级是可变的，令它随等待时间延长而增加。当一个作业等待时间过长时，其优先级也会很高。并且在利用该算法时，每次要进行调度之前，都需要先做响应比的计算，显然会增加系统的开销。

# 进程调度

​	进程调度是对系统性能影响最大的一种处理机调度，是OS中必不可少的一种调度。

## 进程调度的任务、机制和方式

### 任务

​	进程调度的任务主要有三：

- **保存处理机的现场信息**：在进行调度时首先需要保存当前进程的处理机的现场信息，如程序计数器、多个通用寄存器中的内容等；
- **按某种算法选取进程**：调度程序按某种算法从就绪队列中选取一个进程，将其状态改为运行状态，并准备把处理机分配给它；
- **把处理器分配个进程**：由**分派程序**把处理器分配给该进程，此时需要将选中进程的进程控制块内有关处理机现场的信息装入处理器相应的各个寄存器中，把处理器的控制权交给该进程，让它从上次的断点处恢复运行；

### 机制

​	为了实现进程调度，在进程调度机制（程序）中，应具有如下三个基本部分：

- **排队器**：为了提高进程调度的效率，应事先将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便调度程序能快速地找到它。每当一个进程转变为就绪状态时，**排队器便将它插入到相应的就绪队列**。（排队器就是将就绪队列分成多个队列，“同类”就绪进程排成一队）
- **分派器**：分派器根据进程调度程序所选定的进程，将其从就绪队列中取出，然后进行从分派器到新选出进程间的上下文切换，将处理机分配给新选出的进程。
- **上下文切换器**：在对处理机进行切换时，会发生**两对**上下文的切换操作：**第一对**上下文切换时，OS将**保存当前进程的上下文**，即把当前进程的处理机寄存器内容保存到该进程的PCB内的相应单元，再装入分派器的上下文，以便分派器运行；**第二对**上下文切换是移出分派器的上下文，而**把新选进程的CPU现场信息装入到处理机的各个相应寄存器中**，以便新选进程运行。



​	在进行上下文切换时，需要执行大量的 `load` 和 `store` 等操作指令，以保存寄存器的内容。即使是现代计算机，每一次上下文切换时所花费的时间大约可执行上千条指令。为此，现在已有靠硬件实现的方式来减少上下文切换时间。一般采用两组或多组寄存器，其中的一组寄存功处理机在系统态时调用，而另一组寄存器供应用程序使用。在这样条件下的上下文切换，只需改变指针，使其指向当前寄存器组即可。

### 方式

​	进程调度可以分为两种方式：

- **非抢占式**：

    ​	采用这种调度方式，**一旦把处理机分配给某进程后，就会直到进程运行完成或因某事件而阻塞时，才能把处理机分配给其他进程**。

    ​	非抢占式策略引起进程调度的原因一般为：

    - 进程执行完毕或因某事件无法执行；
    - 因IO请求而暂停执行；
    - 进程通信或同步中执行了某种原语操作（如`block`）；

    ​	这种调度方式实现简单，系统开销小（相较于抢占式不会发生频繁的进程调度），适用于批处理系统。

- **抢占式**：

    ​	采用这种调度方式，**允许调度程序根据某种规则，去暂停某个正在执行的进程，将分配给该进程的处理机重新分配给另一个进程**。

    ​	抢占式进程调度可以在分时系统中实现人机交互，在实时系统中满足实时任务的需求，在批处理系统中防止长进程长时间占用处理机。但抢占式的实现比较复杂，系统开销也比较大。

    ​	一般地，抢占式都必须遵循某种原则，其中主要有：

    - **优先权原则**：允许较高优先级的新进程抢占当前进程的运行权，将处理机分配给优先权较高的新进程；
    - **短进程优先原则**：当新进程比正在执行的进程（运行时间）明显短时，运行新进程抢占当前进程的运行权，将处理机分配给新进程；
    - **时间片原则**：每个进程按时间片轮转运行，当正在执行的进程时间片用完时，会暂停该进程并重新调度。

## 轮转调度算法

​	该算法是**基于时间片**的轮转调度算法。在轮转法中，系统采用FCFS策略，将所有的就绪进程排成一个就绪队列，并每个一定时间间隔产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，当执行**进程运行完毕**或**时间片用完**时，再次进行调度。

​	在轮转算法中，时间片的大小对系统性能会有很大影响。时间片过小，会导致频繁地发生进程调度和上下文切换，导致系统开销的增加；时间片过大，会导致轮转算法退化成FCFS算法，无法满足短作业和交互式用户的需求。为此，时间片大小一般为一次典型的交互所需要的时间，使大多数交互使进程能在一个时间片内完成，从而可以获得很小的响应时间。

​	该算法主旨是轮流调度就绪队列中的进程，是一种公平性调度算法。

## 优先级调度算法

​	轮转调度算法是假设所有进程的紧迫性都是相同的，而实际情况会有一些非常紧迫的进程存在。因此，在进程调度算法中引入优先级的概念，使得紧迫进程能够较快执行完毕。

​	优先级调度算法又分配非抢占式和抢占式：

- **非抢占式优先级调度算法**：在该算法下，调度程序会将处理机分配给**当前就绪队列**中优先级最高的进程，直到执行完成或因某事件停止执行。即使进程在执行期间，就绪队列的新进入的进程优先级更高，也不会引起进程调度。
- **抢占式优先级调度算法**：在该算法下，调度程序会将处理机分配给就绪队列中优先级最高的进程，但在执行期间如果出现另一个优先级更高的进程，调度程序会重新将处理机分配给更高优先级的进程。该算法适用于对实时性要求较高的系统中。



​	在优先级调度算法中，优先级的确定是关键。一般优先级分为静态优先级和动态优先级：

- **静态优先级**：静态优先级是**在进程创建时确定的，在进程整个运行期间保持不变**。该优先级用一个整数表示，一般由进程类型、进程对资源的需求、用户要求决定整数大小。采用静态优先级的算法可能会导致优先级低的进程长期处于没有被调度的情况。
- **动态优先级**：动态优先级是**会在进程整个运行期间，优先级随着进程等待时间的增加而动态改变的**。如前述的作业调度中的高响应比优先调度算法就是采用了动态优先级的算法。当采用抢占式动态优先级调度算法时，可以防止长进程长期地垄断处理机。

## 多队列调度算法

​	前述的调度算法都是固定的、单一的，无法满足系统中不同用户对进程调度策略的不同要求。多队列调度算法为了解决这些问题，将系统中的进程就绪队列拆分成多个队列，不同类型或性质的进程分配到不同的就绪队列，不同就绪队列可以采用不同的调度算法，不同的就绪队列本身也可以设置不同的优先级。

​	由上述来看，多队列调度算法主要强调多队列，是不同就绪队列上的不同调度算法的结合体。因此在多处理机系统中，可以很方便的为每个处理机设置单独的就绪队列。这样，不同处理机可以采用不同的调度策略，而且对于一个多线程的进程来说，可以将所有线程分配在一个就绪队列，全部在一个处理机运行。也可以分配到不同处理机对应的多个就绪队列上，实现并行执行。

## 多级反馈队列调度算法

​	多级反馈队列调度算法可以说是多队列调度算法的进阶版本，能够较好地满足各种类型的进程需要，是目前公认的较好的进程调度算法。

- **调度机制**：

    描述如下：

    - **设置多个就绪队列**：在系统中设置多个就绪队列，并为每个队列赋予不同的优先级。队列优先级由最高到最低，并且没有相同优先级的队列。不同队列中进程的时间片大小也不相同，优先级越高的队列，所规定的时间片越小。
    - **每个队列都采用FCFS算法**：当新进程进入内存后，首先将它放入优先级最高的队列的末尾，按照FCFS原则等待调度。当进程在时间片内完成则撤离系统，否则将该进程**降级**，即放入优先级第二高的队列的末尾，以此类推直至进程执行完成。值得注意的是，优先级最低的队列无法降级，会采用轮转方式运行。
    - **按队列优先级调度**：调度程序首先调度最高优先级队列中的进程运行，只有当高级的队列都空闲时，低级的队列才会参与调度。如果处理机正分配给某级队列的进程时，有新进程进入更高级的队列，则必须立即暂停正在运行的进程并放入原本所在队列的末尾，将处理机分配给更高优先级队列的进程。也就是说该算法是抢占式优先级调度算法，不过具有优先级属性的是队列，而不是进程。

    **个人总结**：对于低级的队列中进程来说，如果某段时间持续有新进程进入内存，那么低级队列进程将可能长时间得不到执行。但一般处于低级队列的进程都是长进程，对交互性可能没有很大的需求。

- **调度算法的性能**：

    ​	在多级反馈队列调度算法中，如果规定最高优先级队列的时间片略大于多数人机交互进程所需的处理时间时，便能较好地满足各种类型用户的需要。

    - **终端型用户**。由于终端型用户提交的作业多属于交互作业，通常较小，系统只要能使这些作业在最高优先级队列中规定的时间片内完成，便可使终端型用户感到满意。
    - **短批处理作业用户**。对于这类作业，如果可在最高优先级中执行完成，便获得与终端型作业一样的响应时间。对于稍长的短作业，其周转时间仍然很短。
    - **长批处理作业用户**。对于长作业，它将依次在高级到低级队列中执行，最后再按照轮转的方式运行。

​	该算法可以说是优先级、时间片、FCFS、轮转调度和多队列的结合体，考虑到不同类型的进程的需求。

## 基于公平原则的调度算法

​	基于公平原则的调度算法从处理机占用时间的角度出发，使每个进程都能够获得相对公平的调度。

### 保证调度算法

​	该算法能向用户保证调度的公平性。如果在系统中有n个类型相同的进程同时运行，为公平起见，须保证每个进程都获得相同的处理时间1/n。在实施公平调度算法时系统中必须具有这样一些功能：

1. 跟踪计算每个进程自创建以来已经执行的处理时间；
2. 计算每个进程应获得的处理时间，即自创建以来的时间除以n；
3. 计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比；
4. 比较各进程获得处理机时间的比率；
5. 调度程序应选择比率最小的进程，将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率为止；

### 公平分享调度算法

​	在该调度算法中，调度的公平性主要是针对用户而言，使所有用户能获得相同的处理机时间，或所要求的时间比例。然而调度又是以进程为基本单位，为此，必须考虑到每一个用户所拥有的进程数目。

​	该算法主要是使用户能够获得相同的处理机时间，或是以比例分配时间。

## 总结

​	调度算法可以大致分为两种，基于**紧迫性**的算法和基于**公平性**的算法。但并不一定，因为也有将两种需求相结合的算法。

​	不同的调度算法满足不同的需求，不能简简单单的判断算法的优劣，需要从不同角度去评价算法的优劣。

# 实时调度

​	待

# 死锁概述

​	在学习死锁前，应该摒弃死锁只发生在进程同步的想法，死锁的产生不仅仅是进程间争夺互斥锁时产生，还会发生于进程之间的通信。

## 资源问题

​	在系统中存在许多不同类型的资源，引起死锁的资源一般为需要互斥同问访问、不可以被抢占的资源，即临界资源。临界资源根据某些特性大致可以分为**可重用性资源**、**消耗性资源**、**可抢占性资源**和**不可抢占性资源**：

- **可重用性资源**：该类资源是一种可供用户**重复多次使用**的资源，一般指计算机中的硬件资源、同步机制中的信号量资源。对于这些资源的请求和释放一般是通过系统调用来实现的；
- **消耗性资源**：该类资源是一种**临时性资源**，它是在进程运行期间，由进程动态地创建和消耗的。进程间通信的消息就是最典型的消耗性资源；
- **可抢占性资源**：该类资源在某进程获得时，可以被系统或其它进程抢占。CPU、内存均属于可抢占性资源，对于该类资源是不会引起死锁的；
- **不可抢占性资源**：该类资源一旦被某进程获得后，就不能被其它进程或系统抢占，只能在进程用完后自行释放。磁带机、打印机等就属于不可抢占性资源。

​	其中可重用性资源和消耗性资源是相对的，可抢占性资源和不可抢占性资源是相对的。可重用性资源同时也可以是不可抢占性资源，例如打印机等。

## 死锁的几种情况

​	死锁一般是多个进程间对资源的争夺，不仅对不可抢占性资源进行争夺时会引起死锁，对消耗性资源进行争夺时同样会引起死锁。

- **竞争不可抢占性资源引起死锁**：这种情况发生在系统所拥有的不可抢占性资源数量不足以满足多个进程运行的需要。例如，进程A需要两个不可抢占性资源（数量都是一个），资源A和资源B，进程B同样需要这两个资源，进程A申请并获得资源A，同时进程B申请并获得资源B，此时进程A需要的资源B被占用，进入等待，同理进程B也因资源A被占用进入等待，此时两个进程就形成死锁。
- **竞争消耗性资源引起死锁**：这种情况发生在利用消息通信机制进行通信的进程之间。举例说明，现有三个进程：p1、p2、p3，三个消耗性资源（消息）：m1、m2、m3，p1生产m1，消耗m3；p2生产m2，消耗m1；p3生产m3，消耗m2。也就说每个进程都有两个操作，生产和消耗。如果三个进程中有一个进程先生产消息，那么就不会形成死锁，但是如果三个进程都需要先消耗消息才能生产，那么就会形成死锁，因为三个进程之间的消息通道没有一个消息。

## 死锁的定义

​	死锁的一般定义为：如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的时间，那么该组进程是死锁的。

​	**个人理解**：其中一组进程指的是对资源的需求相同的进程组，或者说是相同类型的进程。死锁也可这样定义：某进程正在等待另外一个无法正常释放资源的进程，这样就形成了死锁。

## 死锁的必要条件

​	形成进程死锁有如下四个必要条件，如果其中一个不成立，那么死锁就不会形成：

- **互斥条件**：进程对所分配到的资源进行排它性使用，即资源只能被某进程独占，其他进程申请时需要等待直至资源被释放；
- **请求和保持条件**：某进程在已经拥有至少一个资源，去申请另外的互斥资源且等待该资源释放（被阻塞）时，对自己拥有的资源持续持有不释放；
- **不可抢占条件**：进程已获得的资源不能被抢占，只能在进程使用完后释放；
- **循环等待条件**：发生死锁时，必然存在一个进程—资源的循环链，即互相等待；

**个人问题**：在上述的死锁情况中，消耗性资源造成的死锁是不具有不可抢占条件的，但为什么还是形成死锁了？

## 死锁的处理方法

​	死锁的处理方法可归纳为如下四种：

- **预防死锁**：是一种直观且简单的事先预防方法。该方法通过设置某些限制条件，去破坏四个必要条件中的一个或多个来达到预防死锁的目的。
- **避免死锁**：属于事先预防策略，但该方法不事先采取限制措施破坏必要条件，而是在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免发生死锁；

> **个人理解**：上述两种方法都是事先预防方法，目的是一样的。但手段（方式）不同，预防死锁是破坏必要条件预防死锁，避免死锁是在资源分配时采取某种方法避免死锁；

- **检测死锁**：该方法不事先采取任何措施，允许进程在运行过程中发生死锁。但可通过检测机构及时地检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来；
- **解除死锁**：与检测死锁配套使用。在检测出死锁时，就采取相应措施解除死锁。常用方法是撤销一些进程，回收它们的资源，将资源分配给已处于阻塞状态的进程；

​	上述四中方法，从上到下对死锁的防范程度逐渐减弱，但对应的是资源利用率的提高，以及进程因资源因素而阻塞的频度下降（即并发程度提高）。

# 预防死锁

​	预防死锁方法通过破坏死锁的必要条件来避免发生死锁。而在四个必要条件中，互斥条件是非共享资源所必须的，不仅不能改变，还应加以保证，因此主要破坏另外三个条件。

## 破坏请求和保持条件

​	请求和保持条件中的资源主要指的是不可抢占性资源，因为只有保持这类资源才可能产生死锁。为了破坏请求和保持条件，系统必须保证当一个进程在请求资源时，它不能持有不可抢占性资源。破坏该条件可通过如下两种协议实现：

- **第一种协议（一次性申请协议）**：

    ​	该协议规定，所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。只要其中一个资源不满足进程的需求，即使其他资源空闲也不分配。这样的进程在其运行过程中不会请求任何资源，在其请求资源时不持有任何资源。

    ​	该协议简单且安全，但缺点却是明显的：

    - 资源被严重浪费，资源利用率低下，甚至一些进程申请的资源只在运行期间使用一瞬间；
    - 进程会产生饥饿现象，可能在很长一段时间无法运行；

- **第二种协议（边用边释放协议）**：

    	第一种协议的改进，该协议允许一个进程只获得运行初期所需的资源后，便开始运行。进程在运行过程中，逐步释放已用完的全部资源，然后再申请新的所需资源。也就是说该协议边用边释放，至于是全部释放完再申请还是释放一部分就申请，还是要看具体实现。

## 破坏不可抢占条件

​	为了能破坏不可抢占条件，协议规定，当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。该协议以进程主动释放不可抢占资源的方式实现“可抢占”资源

​	该方法实现比较复杂，且需要付出很大的代价。因为不可被抢占资源通常都是一些硬件资源，如打印机等，如果在使用后“被抢占”，可能会造成工作失效。这种策略也存在频繁的申请和释放操作问题，导致系统开销增加，降低系统吞吐量。

## 破坏循环等待条件

​	破坏循环等待条件的方法是，将系统中所有资源类型进行线性排序，并赋予不同的唯一序号（类型相同序号相同），然后规定每个进程必须按序号**递增的顺序**（非连续）请求资源。如果需要多个同类型的资源单元，则必须一起申请。如果进程需要申请比现持有资源序号低的资源，则必须先释放所有具有相同和更高序号的资源后，才能申请序号低的资源（即申请的资源要比所有持有资源高）。

​	采用这种策略时，资源的序号如何决定就是重点。通常是根据大多数进程需要资源的先后顺序来决定，即资源所需顺序的一般性。

​	该策略的问题有：一些进程资源需求顺序与系统规定的顺序不同，甚至完全相反；限制了新类型设备的增加，因为系统规定序号是必须相对稳定的。总的来说，规定顺序太死板了，缺少灵活性。

## 总结

​	预防死锁方法死锁防范程度是最高的，但是资源利用率却是最低的。在该死锁处理方法中，进程的阻塞次数会因为资源问题而增加，导致并发性降低。

# 避免死锁

​	避免死锁是在资源动态分配过程中，防止系统进入不安全状态，以避免死锁的发生。

## 系统安全状态

​	在避免死锁方法中，将系统的状态分为安全状态和不安全状态，安全状态不会发生死锁，不安全状态可能会产生死锁。系统在进行资源分配之前，都应先计算此次资源分配的安全性，若此次分配不会导致系统进入不安全状态，才可将资源分配给进程，反之进程需要等待。

### 安全状态和不安全状态

​	安全状态是指系统能按某种进程推进顺序（P1，P2，...，Pn）为每个进程 Pi 分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都顺利地完成。此时称（P1，P2，...，Pn）为安全序列。（即现有的空闲资源能够在一个进程序列中正常分配，序列在前的进程先获得资源，然后用完就释放）

​	如果系统找不到上述的安全序列，则称系统处于不安全状态。处于不安全状态的系统可能会进入死锁状态，由此看来，避免死锁的主要方式就是在资源分配时，避免系统进入不安全状态。

​	举例说明：现有进程P1，P2，P3，12个单元的资源A 。P1运行需要10个，P2运行需要4个，P3运行需要9个。假设在 T0 时刻，进程P1、P2和P3已经分别获得5个、2个和2个资源，空闲资源3个，如下表所示

| 进程 | 最大需求 | 已分配 | 空闲 |
| :--: | :------: | :----: | :--: |
|  P1  |    10    |   5    |  3   |
|  P2  |    4     |   2    |      |
|  P3  |    9     |   2    |      |

​	通过分析可以得出，在 T0 时刻系统是安全的，因为存在一个资源分配的安全序列（P2，P1，P3），即只要系统按照该进程序列分配资源，则能使每个进程都顺序完成。而一旦系统将资源先分配给P1或P3，系统都将处于不安全状态。

​	总的来说，避免死锁的基本思想就是确保系统始终处于安全状态。当一个进程请求一个空闲资源时，系统需要对该请求进行计算，若分配后仍处于安全状态，才会将资源分配给进程。

## 利用银行家算法避免算法

​	最具有代表性的避免死锁的算法是 Dijkstra 的银行家算法。结合上述的避免死锁方法的基本过程，我们知道要计算安全状态需要三种信息：**进程所需的各类资源的最大量**（不得超过系统所拥有资源的总量）、**各类资源的空闲量**、**进程所需各类资源的已分配量**。

​	同样，银行家算法也定义了四种数据结构来计算安全状态：

​	关于下述的各变量的解释：m 代表资源类型的数量、n 代表进程的数量、i 代表进程的“号码”、j 代表资源类型的“号码”、k 代表资源数量（在不同数据结构中意思有偏差）。

- **可利用资源向量 Available**：

    ​	描述系统中可利用的资源。这是一个含有 m 个元素的数组，其中的每个元素代表一类可利用资源的数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而**动态地改变**。如果 Available[j] = k，则表示该系统中现有 k 个 Rj 类资源。 

- **最大需求矩阵 Max**：

    ​	描述所有进程对各类资源的最大需求（整个进程生命周期）。这是一个 n×m 的矩阵，它定义了系统中每一个进程对每一类资源的最大需求。如果 Max[i ,j] = k，则表示进程Pi 需要 Rj类资源的最大数目为 k。

- **分配矩阵 Allocation**：

    ​	描述系统中的资源分配情况。这是一个 n×m 的矩阵，定义了系统中每一类资源当前已分配给每一个进程的资源数。如果 Allocation[i, j] = k，则表示进程Pi 当前已分得 Rj类资源的数目为 K。

- **需求矩阵 Need**：

    ​	描述所有进程还需要多少资源。这是一个 n×m 的矩阵，定义了系统中每一个进程还需要的每一类资源数。如果 Need[i, j] = k，则表示进程 Pi 还需要 k个 Rj类资源才能完成任务。

    其中三个矩阵间的关系为： Need[i, j] = Max[i, j] - Allocation[i, j]

**银行家算法**：

​	设进程Pi 的资源请求向量为 Reqi，即 Reqi[j] = k 表示进程Pi 申请 k 个 Rj类型资源。当进程Pi 发出资源请求后，会进行如下步骤：

1. 如果 Reqi[j] <= Need[i, j]，则执行步骤2，否则认为申请的资源数量超过进程Pi 所需要的数量而报错；

2. 如果 Req[j] <= Available[j]，则执行步骤3，否则当前空闲资源不足以分配，Pi必须等待；

3. 系统尝试性分配资源给进程Pi，并修改以下数据结构的数值：

    ​	Available[j] = Available - Reqi[j];

    ​	Need[i, j] = Need[i, j] - Reqi[j];

    ​	Allocation[i, j] = Allocation[i, j] + Reqi[j];

4. 系统执行安全性算法，检查此次分配后系统是否处于安全状态。若安全，则正式分配资源给进程Pi，否则这次尝试性分配作废，恢复原来的状态，并让进程Pi 等待。

**安全性算法**：

​	基本步骤如下：

1. 设置两个向量：工作向量Work，表示系统可提供给进程继续运行所需的各类资源数目，它含有 m 个元素（m类资源），初始值为 Work = Available；标志向量Finish，它表示系统未来某时刻的资源数量能够使进程完成，初始值为 Finish[i] = false；

2. 从进程集合中找到一个满足如下条件的进程：

    ① Finish[i] = false；

    ② Need[i, j] <= Work[j]；

    若找到，执行步骤3，否则执行步骤4；

3. 满足步骤2条件的进程Pi，因其还需要的资源数量小于此刻系统可提供的资源数量，所以可以顺利执行直至完成，并释放出分配给它的资源，伪代码表示为：

    ① Work[j] = Work[j] + Aollaction[i, j]；

    ② Finish[i] = true；

    ③ go to step 2；

4. 如果所有进程的 Finish[i] 都为 true，则表示系统处于安全状态，否则系统处于不安全状态。



## 总结

​	避免死锁方法给系统定义了两种状态，安全状态和不安全状态。在分配资源时计算分配后系统会处于什么状态，由此判断是否分配。虽然不安全状态不一定会产生死锁，但为了避免死锁，应该防止系统进入这种可能产生死锁的状态。

​	银行家算法与安全性算法都是一种尝试性的算法，即尝试性地分配资源。其中安全性算法可以通过回溯实现，目的是为了找出一个安全序列。安全性算法主要思想是，在进程集合中找到一个尚需资源数量小于或等于当前时刻可分配资源数量的进程Pi，将分配给它的资源数量回收（不是真正的回收），再标记该进程能够顺利完成，然后重复这个动作直至进程集合中所有进程都能顺利完成。

​	PS：判断系统处于不安全状态可以通过判断两轮遍历中进程Finish为true的数量是否变化，如果没有变化则认为找不到安全序列，处于不安全状态。

# 死锁的检测与解除

​	如果在系统中，既不采取死锁预防措施，也未配有死锁避免算法，系统很可能会发生死锁。在这种情况下，系统应当有死锁检测和死锁解除的算法。

## 死锁检测

​	检测系统是否处于死锁状态需要知道资源的分配情况，以某种算法利用这些分配信息，判断系统当前是否处于死锁状态。为此，检测死锁需要资源分配情况和检测算法。

- **资源分配图**：

    ​	资源分配图是用于描述系统中资源分配情况的数据结构。该图是由一组节点 N 和一组边 E 所组成的有向图。其中节点 N 有两种类型：进程节点Pi 和资源节点Ri。资源分配图的定义如下： 

    - N = P ∪ R， N为总节点结合，P为进程节点集合，R为资源节点集合；
    - 边集合E 中的一条边e∈E，都连接着 P 中的节点和 R 中的节点，即 e = {Pi，Rj} 或 e = {Rj，Pi}。边 e 根据指向又分为资源请求边和资源分配边，资源请求边是进程节点指向资源节点，资源分配边是资源节点指向进程节点，即边的两个节点的类型必须是不同的。

- **检测算法**：

    ​	

## 死锁解除





# 参考资料

《计算机操作系统》（第四版）——汤小丹著


# 处理机调度的层次和调度算法的目标

​	调度的实质是一种资源分配，处理机调度是对处理机资源进行分配。处理机调度算法是指根据处理机分配策略所规定的处理机资源分配算法。

## 处理机调度的层次

- **高级调度**：

    ​	高级调度又称长程调度或**作业调度**，它的**调度对象是作业**。主要功能是根据某种算法，**决定将 外存 上处于后备队列中的哪几个作业调入 内存，为它们创建进程、分配必要的资源，并将它们放入就绪队列**。高级调度主要用于多道批处理系统中，而在分时和实时系统中不设置高级调度。

- **中级调度**：

    ​	中级调度又称为**内存调度**。引入中级调度的**目的是提高内存利用率和系统吞吐量**。主要功能是**把暂时不能运行的进程调至外存等待**，此时进程的状态为**就绪外存状态**（或挂起状态）。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把**外存上的已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态，放入就绪队列中**。中级调度实际上就是存储器管理中的对换功能，会在存储器管理篇详细介绍。

- **低级调度**：

    ​	低级调度又称为短程调度或**进程调度**，它的调度对象是进程（或内核级线程）。其主要功能是根据某种算法，**决定就绪队列中的哪个进程应该获得处理机，并由分派程序将处理机分配给选中的进程**。进程调度是最基本的一种调度，很多系统都配置这级调度。 

​	上述三种调度中，进程调度的运行频率最高，内存调度次之，作业调度最低。进程调度运行频繁且时间短，因此称为短程调度，为避免调度程序本身占有太多CPU时间，进程调度算法不应太复杂。作业调度运行周期长且时间长，因此称为长程调度。内存调度介于两种调度之间，因此称为中程调度。

​	**个人总结**：从进程状态上看，高级调度是与新进程的调度有关，中级调度与挂起进程有关，低级调度与就绪进程有关；从存储器上看，高级调度和中级调度都与内存和外存有关，低级调度与内存（就绪队列）有关。**低级调度决定哪些进程获得处理机资源**，中级调度与高级调度决定哪些进程进入就绪队列。

## 调度算法的目标

​	一般来说，调度算法和方式很大程度取决于操作系统的类型及其设计目标。在批处理系统、分时心痛和实时系统中，通常都采用不同的调度方式和算法。

### 处理机调度算法的共同目标

- **资源利用率**：

    ​	尽可能使系统中的处理机和其他所有资源都保持忙碌状态。

    ​	CPU利用率计算方法：
    $$
    CPU的利用率=（CPU有效工作时间）/（CPU有效工作时间 + CPU空闲时间）
    $$

- **公平性**：

    ​	指**应使各个进程都获得合理的CPU时间，不会发生进程“饥饿现象”**。公平性是相对的，对相同类型的进程应获得相同的服务；但对于不同类型的进程，由于其紧急程度或重要性的不同，则应提供不同的服务。

- **平衡性**：

    ​	由于在系统中具有多种类型的进程，有的属于计算型作业，有的属于IO型。为使系统中的CPU和各种外部设备都能经常处于忙碌状态，调度算法应尽可能保持系统资源使用的平衡性。

- **策略强制执行**：

    ​	对所制订的策略其中包括安全策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟也要执行。

### 批处理系统的目标

- **平均周转时间短**：

    ​	周转时间是**指从作业被提交给系统开始，到作业完成为止的这段时间间隔**（称为作业周转时间）。它包括四部分时间：**作业在外存后备队列上等待作业调度的时间**、**进程在就绪队列上等待进程调度的时间**、**进程在CPU上执行的时间**、**进程等待IO操作完成的时间**。其中后三项在一个作业的整个处理过程中，可能发生多次。

- **系统吞吐量高**：

    ​	吞吐量是**指在单位时间内系统所完成的作业数**。因此它与批处理作业的平均长度有关，如果为了提高系统吞吐量，就应尽量地多选择短作业运行。

- **处理机利用率高**：

    ​	对于大、中型计算机，CPU价格十分昂贵，致使处理机的利用率成为衡量系统性能的十分重要的指标；而调度方式和算法又对处理机的利用率起着十分重要的作用。如果但是为使处理机利用率高，应尽量多地选择计算量打的作业运行。有上述可以看出，这些要求之间是存在着一定矛盾的。

### 分时系统的目标

- **响应时间快**：

    ​	响应时间快是选择分时系统中**进程调度算法的重要准则**。响应时间是指从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为止的一段时间间隔。它包括三部分时间：

    - 请求信息从键盘输入开始，直至将其传送到处理机的时间；
    - 处理机对请求信息进行处理的时间；
    - 将所形成的响应信息回送到终端显示器的时间；

- **均衡性**：

    ​	用户对响应时间的要求并非完全相同。通常用户对较复杂任务的响应时间允许较长，而对简单任务的响应时间则要短。所谓均衡性，是**指系统响应时间的快慢应与用户所请求服务的复杂性相适应**。

### 实时系统的目标

- **截止时间的保证**：

    ​	截止时间是**指某任务必须开始执行的最迟时间，或必须完成的最迟时间**。对于严格的实时系统，其调度方式和调度算法必须能保证这一点，否则将可能造成难以预料的后果。对于实时系统而言，调度算法的一个主要目标是保证实时任务对截止时间的要求。对于HRT任务，其调度方式和调度算法必须确保截止时间的要求，否则将可能造成难以预料的后果；而对于SRT任务，其调度方式和调度算法也应基本上能保证对截止时间的要求。

- **可预测性**：

    ​	在实时系统中，可预测性显得非常重要。例如，在多媒体系统中，无论是电影还是电视剧都应是连续播放的，这就提供了请求的可预测性。

# 作业与作业调度

​	在多道批处理系统中，作业是用户提交给系统的一项相对独立的**工作**。操作员把用户提交的作业通过相应的输入设备输入到磁盘存储器，并保存在一个后备作业队列中，再由作业调度程序将其从外存调入内存。

## 批处理系统中的作业

- **作业和作业步**：

    - **作业**：作业是一个**比程序更为广泛的概念**，它不仅包含了通常的程序和数据，而且还应配有一份**作业说明书**，系统根据该说明书来对程序的运行进行控制。在批处理系统中，是以作业为基本单位从外存调入内存的。
    - **作业步**：通常，在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。我们把其中的**每一个加工步骤称为一个作业步**，各作业步之间存在着相互关系，往往是上一个作业步的输出作为下一个作业步的输入。例如，一个典型的作业可分为：”编译“作业步，”链接装配“作业步和”运行“作业步。

- **作业控制块**：

    ​	为了管理和调度作业，会为每个作业设置一个作业控制块 JCB，是作业在系统存在的标志，保存了管理和调度所需的全部信息。通常 JCB中包含有：作业标识、用户名称、用户账号、**作业类型**（IO繁忙型、CPU繁忙型、批量型、终端型）、**作业状态**、调度信息、资源需求、资源使用情况等。

- **作业运行的三个阶段和三种状态**：

    ​	作业从进入系统到运行结束，通常需要经历收容、运行和完成三个阶段。相应的作业也就有“后备状态”、“运行状态”和“完成状态”。

    - 收容阶段：操作员把用户提交的作业通过某种输入方式或SPOOLing系统输入到硬盘上，再为该作业创建 JCB，并把它放入作业后备队列中。此时的作业为”后备状态“；
    - 运行阶段：当作业被作业调度选中后，便为它分配必要的资源和建立进程，并将它放入就绪队列。一个作业从第一次进入就绪状态开始，直到它运行结束前，在此期间都处于”运行状态“；
    - 完成阶段：当作业运行完成、或发生异常情况而提前结束时，作业便进入完成阶段，相应的作业状态为”完成状态“。此时系统中的”终止作业“程序将会回收已分配给该作业的作业控制块和所有资源，并将作业运行结果信息形成输出文件后输出。

## 先来先服务和短作业优先调度算法

- **先来先服务（first-come first-served，FCFS）**：

    ​	FCFS是最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。该算法中，系统将按照作业到达的**先后次序**来进行调度，或者说它是优先考虑在系统中等待时间最长的作业，而不管该作业所需执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程，然后放入就绪队列。

    ​	FCFS并不是一个很好的算法，但经常把它与其它调度算法相结合使用，形成一种更为有效的调度算法。

- **短作业优先（short job frist，SJF）**：

    ​	因为实际情况中，短作业占有很大比例，为了使它们能比长作业优先执行，而产生了短作业优先调度算法。该算法就如名字一般，作业越短，优先级越高。作业的长短是以作业所要求的运行时间来衡量的，所以运行时间越短的作业优先调入内存运行。

    ​	SJF算法缺点也很多：必须预知作业的运行时间；对长作业非常不利；使用该算法无法实现人机交互；紧迫作业不能及时处理。

## 优先级调度算法和高响应比优先调度算法

- **优先级调度算法（priority-scheduling algorithm，PSA）**：

    ​	在优先级调度算法中，是基于**作业的紧迫程度**，由外部赋予作业相应的优先级，调度算法是根据该优先级进行调度的。这样就可以保证紧迫性作业优先运行。优先级调度算法可作为作业调度算法，也可作为进程调度算法。使用该算法时，系统会从后备队列中选择若干个优先级最高的作业装入内存。

- **高响应比优先调度算法（highest response ratio next，HRRN）**：

    ​	HRRN调度算法是既考虑作业的等待时间，又考虑作业运行时间的调度算法，因此既照顾了短作业，又不致使长作业的等待时间过长，从而改善了处理机调度的性能。

    ​	在该算法中，会为每个作业引入一个**动态优先级**，即优先级是可变的，令它随等待时间延长而增加。当一个作业等待时间过长时，其优先级也会很高。并且在利用该算法时，每次要进行调度之前，都需要先做响应比的计算，显然会增加系统的开销。

# 进程调度

​	进程调度是对系统性能影响最大的一种处理机调度，是OS中必不可少的一种调度。

## 进程调度的任务、机制和方式

### 任务

​	进程调度的任务主要有三：

- **保存处理机的现场信息**：在进行调度时首先需要保存当前进程的处理机的现场信息，如程序计数器、多个通用寄存器中的内容等；
- **按某种算法选取进程**：调度程序按某种算法从就绪队列中选取一个进程，将其状态改为运行状态，并准备把处理机分配给它；
- **把处理器分配个进程**：由**分派程序**把处理器分配给该进程，此时需要将选中进程的进程控制块内有关处理机现场的信息装入处理器相应的各个寄存器中，把处理器的控制权交给该进程，让它从上次的断点处恢复运行；

### 机制

​	为了实现进程调度，在进程调度机制（程序）中，应具有如下三个基本部分：

- **排队器**：为了提高进程调度的效率，应事先将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便调度程序能快速地找到它。每当一个进程转变为就绪状态时，**排队器便将它插入到相应的就绪队列**。（排队器就是将就绪队列分成多个队列，“同类”就绪进程排成一队）
- **分派器**：分派器根据进程调度程序所选定的进程，将其从就绪队列中取出，然后进行从分派器到新选出进程间的上下文切换，将处理机分配给新选出的进程。
- **上下文切换器**：在对处理机进行切换时，会发生**两对**上下文的切换操作：**第一对**上下文切换时，OS将**保存当前进程的上下文**，即把当前进程的处理机寄存器内容保存到该进程的PCB内的相应单元，再装入分派器的上下文，以便分派器运行；**第二对**上下文切换是移出分派器的上下文，而**把新选进程的CPU现场信息装入到处理机的各个相应寄存器中**，以便新选进程运行。



​	在进行上下文切换时，需要执行大量的 `load` 和 `store` 等操作指令，以保存寄存器的内容。即使是现代计算机，每一次上下文切换时所花费的时间大约可执行上千条指令。为此，现在已有靠硬件实现的方式来减少上下文切换时间。一般采用两组或多组寄存器，其中的一组寄存功处理机在系统态时调用，而另一组寄存器供应用程序使用。在这样条件下的上下文切换，只需改变指针，使其指向当前寄存器组即可。

### 方式

​	进程调度可以分为两种方式：

- **非抢占式**：

    ​	采用这种调度方式，**一旦把处理机分配给某进程后，就会直到进程运行完成或因某事件而阻塞时，才能把处理机分配给其他进程**。

    ​	非抢占式策略引起进程调度的原因一般为：

    - 进程执行完毕或因某事件无法执行；
    - 因IO请求而暂停执行；
    - 进程通信或同步中执行了某种原语操作（如`block`）；

    ​	这种调度方式实现简单，系统开销小（相较于抢占式不会发生频繁的进程调度），适用于批处理系统。

- **抢占式**：

    ​	采用这种调度方式，**允许调度程序根据某种规则，去暂停某个正在执行的进程，将分配给该进程的处理机重新分配给另一个进程**。

    ​	抢占式进程调度可以在分时系统中实现人机交互，在实时系统中满足实时任务的需求，在批处理系统中防止长进程长时间占用处理机。但抢占式的实现比较复杂，系统开销也比较大。

    ​	一般地，抢占式都必须遵循某种原则，其中主要有：

    - **优先权原则**：允许较高优先级的新进程抢占当前进程的运行权，将处理机分配给优先权较高的新进程；
    - **短进程优先原则**：当新进程比正在执行的进程（运行时间）明显短时，运行新进程抢占当前进程的运行权，将处理机分配给新进程；
    - **时间片原则**：每个进程按时间片轮转运行，当正在执行的进程时间片用完时，会暂停该进程并重新调度。

## 轮转调度算法

​	该算法是**基于时间片**的轮转调度算法。在轮转法中，系统采用FCFS策略，将所有的就绪进程排成一个就绪队列，并每个一定时间间隔产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，当执行**进程运行完毕**或**时间片用完**时，再次进行调度。

​	在轮转算法中，时间片的大小对系统性能会有很大影响。时间片过小，会导致频繁地发生进程调度和上下文切换，导致系统开销的增加；时间片过大，会导致轮转算法退化成FCFS算法，无法满足短作业和交互式用户的需求。为此，时间片大小一般为一次典型的交互所需要的时间，使大多数交互使进程能在一个时间片内完成，从而可以获得很小的响应时间。

​	该算法主旨是轮流调度就绪队列中的进程，是一种公平性调度算法。

## 优先级调度算法

​	轮转调度算法是假设所有进程的紧迫性都是相同的，而实际情况会有一些非常紧迫的进程存在。因此，在进程调度算法中引入优先级的概念，使得紧迫进程能够较快执行完毕。

​	优先级调度算法又分配非抢占式和抢占式：

- **非抢占式优先级调度算法**：在该算法下，调度程序会将处理机分配给**当前就绪队列**中优先级最高的进程，直到执行完成或因某事件停止执行。即使进程在执行期间，就绪队列的新进入的进程优先级更高，也不会引起进程调度。
- **抢占式优先级调度算法**：在该算法下，调度程序会将处理机分配给就绪队列中优先级最高的进程，但在执行期间如果出现另一个优先级更高的进程，调度程序会重新将处理机分配给更高优先级的进程。该算法适用于对实时性要求较高的系统中。



​	在优先级调度算法中，优先级的确定是关键。一般优先级分为静态优先级和动态优先级：

- **静态优先级**：静态优先级是**在进程创建时确定的，在进程整个运行期间保持不变**。该优先级用一个整数表示，一般由进程类型、进程对资源的需求、用户要求决定整数大小。采用静态优先级的算法可能会导致优先级低的进程长期处于没有被调度的情况。
- **动态优先级**：动态优先级是**会在进程整个运行期间，优先级随着进程等待时间的增加而动态改变的**。如前述的作业调度中的高响应比优先调度算法就是采用了动态优先级的算法。当采用抢占式动态优先级调度算法时，可以防止长进程长期地垄断处理机。

## 多队列调度算法

​	前述的调度算法都是固定的、单一的，无法满足系统中不同用户对进程调度策略的不同要求。多队列调度算法为了解决这些问题，将系统中的进程就绪队列拆分成多个队列，不同类型或性质的进程分配到不同的就绪队列，不同就绪队列可以采用不同的调度算法，不同的就绪队列本身也可以设置不同的优先级。

​	由上述来看，多队列调度算法主要强调多队列，是不同就绪队列上的不同调度算法的结合体。因此在多处理机系统中，可以很方便的为每个处理机设置单独的就绪队列。这样，不同处理机可以采用不同的调度策略，而且对于一个多线程的进程来说，可以将所有线程分配在一个就绪队列，全部在一个处理机运行。也可以分配到不同处理机对应的多个就绪队列上，实现并行执行。

## 多级反馈队列调度算法

​	多级反馈队列调度算法可以说是多队列调度算法的进阶版本，能够较好地满足各种类型的进程需要，是目前公认的较好的进程调度算法。

- **调度机制**：

    描述如下：

    - **设置多个就绪队列**：在系统中设置多个就绪队列，并为每个队列赋予不同的优先级。队列优先级由最高到最低，并且没有相同优先级的队列。不同队列中进程的时间片大小也不相同，优先级越高的队列，所规定的时间片越小。
    - **每个队列都采用FCFS算法**：当新进程进入内存后，首先将它放入优先级最高的队列的末尾，按照FCFS原则等待调度。当进程在时间片内完成则撤离系统，否则将该进程**降级**，即放入优先级第二高的队列的末尾，以此类推直至进程执行完成。值得注意的是，优先级最低的队列无法降级，会采用轮转方式运行。
    - **按队列优先级调度**：调度程序首先调度最高优先级队列中的进程运行，只有当高级的队列都空闲时，低级的队列才会参与调度。如果处理机正分配给某级队列的进程时，有新进程进入更高级的队列，则必须立即暂停正在运行的进程并放入原本所在队列的末尾，将处理机分配给更高优先级队列的进程。也就是说该算法是抢占式优先级调度算法，不过具有优先级属性的是队列，而不是进程。

    **个人总结**：对于低级的队列中进程来说，如果某段时间持续有新进程进入内存，那么低级队列进程将可能长时间得不到执行。但一般处于低级队列的进程都是长进程，对交互性可能没有很大的需求。

- **调度算法的性能**：

    ​	在多级反馈队列调度算法中，如果规定最高优先级队列的时间片略大于多数人机交互进程所需的处理时间时，便能较好地满足各种类型用户的需要。

    - **终端型用户**。由于终端型用户提交的作业多属于交互作业，通常较小，系统只要能使这些作业在最高优先级队列中规定的时间片内完成，便可使终端型用户感到满意。
    - **短批处理作业用户**。对于这类作业，如果可在最高优先级中执行完成，便获得与终端型作业一样的响应时间。对于稍长的短作业，其周转时间仍然很短。
    - **长批处理作业用户**。对于长作业，它将依次在高级到低级队列中执行，最后再按照轮转的方式运行。

​	该算法可以说是优先级、时间片、FCFS、轮转调度和多队列的结合体，考虑到不同类型的进程的需求。

## 基于公平原则的调度算法

​	基于公平原则的调度算法从处理机占用时间的角度出发，使每个进程都能够获得相对公平的调度。

### 保证调度算法

​	该算法能向用户保证调度的公平性。如果在系统中有n个类型相同的进程同时运行，为公平起见，须保证每个进程都获得相同的处理时间1/n。在实施公平调度算法时系统中必须具有这样一些功能：

1. 跟踪计算每个进程自创建以来已经执行的处理时间；
2. 计算每个进程应获得的处理时间，即自创建以来的时间除以n；
3. 计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比；
4. 比较各进程获得处理机时间的比率；
5. 调度程序应选择比率最小的进程，将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率为止；

### 公平分享调度算法

​	在该调度算法中，调度的公平性主要是针对用户而言，使所有用户能获得相同的处理机时间，或所要求的时间比例。然而调度又是以进程为基本单位，为此，必须考虑到每一个用户所拥有的进程数目。

​	该算法主要是使用户能够获得相同的处理机时间，或是以比例分配时间。

## 总结

​	调度算法可以大致分为两种，基于**紧迫性**的算法和基于**公平性**的算法。但并不一定，因为也有将两种需求相结合的算法。

​	不同的调度算法满足不同的需求，不能简简单单的判断算法的优劣，需要从不同角度去评价算法的优劣。

# 实时调度

​	待

# 死锁概述



# 预防死锁



# 避免死锁



# 死锁的检测与解除